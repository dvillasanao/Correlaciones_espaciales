---
title: "An√°lisis estad√≠stico espacial"
subtitle: "Utilizando el √≠ndice de marginaci√≥n a nivel municipal"
author: "Diana Villasana Ocampo"
knit: (function(inputFile, encoding) {
       rmarkdown::render(inputFile, encoding = encoding, output_dir = "../Output/")
  })
output:
   html_document:
      code_folding: hide
      highlight: tango
      theme: flatly
      toc: true
      toc_depth: 3
      toc_float:
        collapsed: yes
---

```{=html}
<style type="text/css">
body {
text-align: justify;
font-style: normal;
font-family: "Montserrat";
font-size: 12px
}
h1.title {
  font-size: 40px;
  color: #000D3B;
}
h1 {
  color: #B6854D;
}
h2 {
  color: #172984;
}
h3 {
  color: #172984;
}
</style>
```

```{=html}
<style>
.nav>li>a {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #1C3BA4
}
.nav-pills>li.active>a, .nav-pills>li.active>a:hover, .nav-pills>li>a:focus {
    color: #ffffff;
    background-color: #09C2BC
}
</style>
```

```{=html}
<style>
.tile1-text {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #0A6A87;
    list-style: none;
}
.top1-tiles a:nth-of-type(1):hover, .top-tiles1 a:nth-of-type(1):focus{
    color: #ffffff;
    background: #0A6A87
}
</style>
```

```{=html}
<style>
.tile2-text {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #0A6CC8;
    list-style: none;
}
.top2-tiles a:nth-of-type(1):hover, .top2-tiles a:nth-of-type(1):focus{
    color: #ffffff;
    background: #0A6CC8
}
</style>
```

```{=html}
<style>
.math {
  font-size: 15px;
  color: #B6854D;
}
</style>
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE, 
                      cache.lazy = FALSE, class.source = "fold-show")
knitr::opts_knit$set(root.dir = here::here())
setwd(here::here())
```

```{r,echo=FALSE, eval=FALSE}
rm(list = ls())
```

```{r, echo = FALSE, results=FALSE}
# Paquetes que se usaron en el documento 
require(dplyr)          #A Grammar of Data Manipulation 
require(ggplot2)        # Generar gr√°ficos ggplot y la geometr√≠a de un mapa
require(RColorBrewer)
require(ggspatial)
require(ggpubr)
require(knitr)
require(kableExtra)
require(openxlsx)
require(readxl)
require(rgdal)          #Para importar shapefiles. 
require(sp)             # Classes and Methos for Spatial Data
library(spdep)    # √çndice de Moran 
require(spdplyr)        #Data manipulation verbs for the sptial classes
require(tidyverse) 
require(unikn)          # Paleta de colores
```

```{r, echo = FALSE, results=FALSE}
# Se descargan las fuentes de la google fonts
require(showtext)
# activar showtext
showtext_auto()
font_add_google("Montserrat", "montserrat")
```

## Objetivo

El an√°lisis espacial es un conjunto de t√©cnicas y herramientas utilizadas para estudiar y comprender patrones, relaciones y procesos geogr√°ficos en un contexto espacial. Es decir, se enfoca en c√≥mo los datos se distribuyen en el espacio y c√≥mo se relacionan entre s√≠, en el c√∫al se utilizan t√©cnicas como el mapeo, estad√≠stica espacial, sistemas de informaci√≥n geogr√°fica (`SIG`)` y la visualizaci√≥n para examinar los datos geogr√°ficos y descubrir patrones y relaciones en ellos.

Estas t√©cnicas permiten la detecci√≥n de patrones y tendencias, la evaluaci√≥n de la accesibilidad y la conectividad, la modelizaci√≥n de procesos geogr√°ficos y la planificaci√≥n y toma de decisiones basadas en la informaci√≥n geogr√°fica. La cuales sirven como ayuda para campos, como la geograf√≠a, planificaci√≥n urbana, epidemiolog√≠a, gesti√≥n de recursos naturales, criminolog√≠a y arqueolog√≠a, entre otros.

## Correlaciones espaciales

Las correlaciones espaciales permiten analizar la relaci√≥n entre variables geogr√°ficas considerando su distribuci√≥n en el espacio. A diferencia de las correlaciones tradicionales, que suponen independencia entre observaciones, las correlaciones espaciales reconocen que valores cercanos tienden a estar m√°s relacionados que aquellos m√°s alejados, fen√≥meno conocido como autocorrelaci√≥n espacial. Este tipo de an√°lisis es fundamental en estudios de patrones geogr√°ficos, como la distribuci√≥n de la pobreza, el acceso a servicios o la din√°mica migratoria, y se mide com√∫nmente mediante indicadores como el `√≠ndice de Moran` o la `estad√≠stica de Geary`. Su aplicaci√≥n ayuda a identificar clusters espaciales, entender din√°micas territoriales y mejorar la toma de decisiones en pol√≠ticas p√∫blicas y planificaci√≥n urbana.

El c√°lculo de la correlaci√≥n espacial se basa en la relaci√≥n entre los valores de una variable y su distribuci√≥n geogr√°fica. Los m√©todos m√°s utilizados son el **√çndice de Moran** y la **estad√≠stica de Geary**, que cuantifican la autocorrelaci√≥n espacial en diferentes escalas.

### 1. √çndice de Moran ($I$)

El **√çndice de Moran** mide la autocorrelaci√≥n espacial global, es decir, qu√© tan similar es una variable en funci√≥n de su ubicaci√≥n. Se calcula como:

$$
I = \frac{N}{W} \times \frac{\sum_{i} \sum_{j} w_{ij} (x_i - \bar{x})(x_j - \bar{x})}{\sum_{i} (x_i - \bar{x})^2}, \quad D : \left\{x \in [-1, 1] \right\}
$$

donde:

\- $N$ es el n√∫mero total de observaciones,

\- $x_i$ y $x_j$ son los valores de la variable en las ubicaciones $i$ y $j$,

\- $\bar{x}$ es la media de la variable,

\- $w_{ij}$ es la matriz de pesos espaciales que define la relaci√≥n entre ubicaciones (por ejemplo, vecindad contigua o distancia),

\- $W$ es la suma de todos los pesos espaciales.

El **√çndice de Moran** var√≠a entre $-1$ y $1$:

\- $I > 0$ indica correlaci√≥n positiva (valores similares est√°n agrupados).

\- $I < 0$ indica correlaci√≥n negativa (valores diferentes est√°n cercanos entre s√≠).

\- $I \approx 0$ sugiere ausencia de autocorrelaci√≥n espacial.

### 2. Estad√≠stica de Geary ($C$)

La estad√≠stica de Geary tambi√©n mide autocorrelaci√≥n espacial, pero es m√°s sensible a las diferencias locales. Se calcula como:

$$
C = \frac{(N-1)}{2W} \times \frac{\sum_{i} \sum_{j} w_{ij} (x_i - x_j)^2}{\sum_{i} (x_i - \bar{x})^2}
$$

donde los t√©rminos son los mismos que en el √çndice de Moran.

El **valor de** $C$ var√≠a entre $0$ y $2$:

\- $C \approx 1$ indica independencia espacial (ausencia de correlaci√≥n).

\- $C < 1$ sugiere autocorrelaci√≥n espacial positiva (valores similares est√°n cerca).

\- $C > 1$ indica autocorrelaci√≥n espacial negativa (valores diferentes est√°n cercanos entre s√≠).

### 3. Estad√≠stica de Getis-Ord ($G_i^*$)

La estad√≠stica de **Getis-Ord** $G_i^*$ es una medida local de autocorrelaci√≥n espacial que identifica clusters de valores altos o bajos en una distribuci√≥n geogr√°fica. Se usa principalmente para detectar **zonas calientes ("hot spots") y zonas fr√≠as ("cold spots")**, lo que la hace √∫til en an√°lisis de crimen, salud p√∫blica, econom√≠a y planificaci√≥n urbana.

#### F√≥rmula de Getis-Ord $G_i^*$:

$$
G_i^* = \frac{\sum_{j} w_{ij} x_j}{\sum_{j} x_j}
$$

donde:\
- $x_j$ es el valor de la variable en la ubicaci√≥n $j$,

\- $w_{ij}$ es el peso espacial entre las ubicaciones $i$ y $j$,

\- $\sum_{j} x_j$ es la suma total de la variable en todas las ubicaciones.

Para interpretar los resultados, se suele estandarizar $G_i^*$ en forma de una puntuaci√≥n $Z$:

$$
Z(G_i^*) = \frac{\sum_j w_{ij} x_j - \bar{X} W_i}{S}
$$

donde:

\- $\bar{X}$ es la media de la variable en toda el √°rea de estudio,

\- $W_i$ es la suma de los pesos espaciales para la ubicaci√≥n $i$,

\- $S$ es la desviaci√≥n est√°ndar de la variable en la regi√≥n.

#### Interpretaci√≥n de $G_i^*$:

-   $Z(G_i^*) > 1.96$ (p \< 0.05) ‚Üí Indica un **hot spot** (zona con valores altos agrupados significativamente).\
-   $Z(G_i^*) < -1.96$ (p \< 0.05) ‚Üí Indica un **cold spot** (zona con valores bajos agrupados significativamente).\
-   $Z(G_i^*) \approx 0$ ‚Üí No hay patrones espaciales significativos.

#### **Diferencia con el √çndice de Moran:**

-   **Moran‚Äôs I** mide la autocorrelaci√≥n espacial **global**, indicando si los valores est√°n agrupados en toda la regi√≥n.\
-   **Getis-Ord** $G_i^*$ detecta **clusters locales**, permitiendo identificar √°reas espec√≠ficas con concentraciones altas o bajas.

#### **Aplicaciones:**

-   En criminolog√≠a, para encontrar **zonas de alta delincuencia**.\
-   En epidemiolog√≠a, para detectar **zonas con alta incidencia de enfermedades**.\
-   En econom√≠a, para analizar **concentraciones de riqueza o pobreza**.\
-   En urbanismo, para identificar **√°reas de crecimiento acelerado o deterioro urbano**.

Esta estad√≠stica es ampliamente utilizada en **Sistemas de Informaci√≥n Geogr√°fica (SIG)** y est√° implementada en software como **ArcGIS, GeoDa y R** (paquetes `spdep` y `sf`).

## Marco Geoestad√≠stico Nacional (MGN) 2020

El **Marco Geoestad√≠stico Nacional (MGN) 2020** del **Instituto Nacional de Estad√≠stica y Geograf√≠a (INEGI)** es un sistema de referencia geogr√°fica que define la divisi√≥n territorial de M√©xico para la recopilaci√≥n, an√°lisis y presentaci√≥n de informaci√≥n estad√≠stica. Se utiliza principalmente en censos y encuestas para garantizar la compatibilidad de datos espaciales a nivel nacional.

#### **Caracter√≠sticas principales del MGN 2020:**

1.  **Unidades geogr√°ficas:**
    -   **√Åreas Geoestad√≠sticas Estatales (AGEE):** corresponden a los estados.\
    -   **√Åreas Geoestad√≠sticas Municipales (AGEM):** coinciden con los municipios.\
    -   **√Åreas Geoestad√≠sticas B√°sicas (AGEB):** subdivisiones de los municipios, utilizadas en zonas urbanas y rurales.\
    -   **Manzanas geoestad√≠sticas:** delimitaciones dentro de las AGEB urbanas.
2.  **Proyecci√≥n y sistema de coordenadas:**
    -   Utiliza el **Sistema de Referencia Geod√©sico ITRF2008** en coordenadas geogr√°ficas con el **datum WGS84**.\
    -   Se presenta en formato vectorial compatible con SIG (Sistemas de Informaci√≥n Geogr√°fica), en formatos como **Shapefile (SHP)** y **GeoJSON**.

#### Shapefile

La funci√≥n `readOGR` del paquete `rgdal`, extrae autom√°ticamente la informaci√≥n utilizada por otros paquetes `SIG` de c√≥digo abierto como QGIS y permite a R manejar una gama m√°s amplia de formatos de datos espaciales. Esta funci√≥n lee datos `OGR` y datos vectoriales, pero solamente permite manejar capas con caracter√≠sticas geom√©tricas (no mezcla puntos, l√≠neas o pol√≠gonos en una sola capa) y a su vez establecer√° un sistema de referencia espacial si la capa tiene dichos metadatos.\
Para leer un archivo `shapefile`, se establecen los siguientes argumentos, como `dsn`, en donde se indica el directorio que contiene los shapes y `layer` que es el nombre expl√≠cito de la capa a trabajar y dichas capas deben de ir sin la extensi√≥n `.shp`.

A continuaci√≥n, se lee el archivo .shp que contiene de manera integrada la divisi√≥n de el √°rea geoestad√≠stica municipal `agem`.

```{r,results=FALSE,class.source = "fold-show"}
shape_estados <- readOGR(dsn ="D:/MGN/MGN 2020/MGN 2020/conjunto_de_datos", 
                             layer = "00ent",
                              encoding = "UTF-8",
                               use_iconv = TRUE)
```

```{r,results=FALSE,class.source = "fold-show"}
shape_municipios <- readOGR(dsn ="D:/MGN/MGN 2020/MGN 2020/conjunto_de_datos", 
                             layer = "00mun",
                              encoding = "UTF-8",
                               use_iconv = TRUE)
```

La funci√≥n `rename()` del paquete `dplyr` permite cambiar el nombre de la columna de la clave geoestad√≠stica a nivel estatal dentro de la base de datos del shape.

```{r,class.source = "fold-show"}
shape_municipios@data <- shape_municipios@data %>%
                          rename("CVE_GEO" = "CVEGEO")
```

### Base de datos

La base de datos del √≠ndice de marginaci√≥n por municipios se encuentra disponible en la p√°gina oficial de [CONAPO](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372) o bien se puede consultar en la p√°gina de [Datos Abiertos](https://datos.gob.mx/) y se presenta en formato `.xlsx` [Consulta](https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad).

Para poder trabajar con la base de datos del √≠ndice de marginaci√≥n a nivel municipal, se elimina la fila que contiene los datos a nivel nacional con la funci√≥n `::filter()` del paquete `dplyr` y por otro lado se cambia el nombre de la columna `CVE_MUN` que hace referencia a la clave geogr√°fica del municipio por `CVE_GEO` para fines pr√°cticos.

```{r, class.source = "fold-show"}
IMM_2020 <- read_xlsx("Bases/IMM_2020.xlsx", sheet = "IMM_2020") %>%
             filter(NOM_ENT != "Nacional") %>%
               mutate(CVE_GEO = CVE_MUN) %>%
                as.data.frame()
```

### SpatialPolygons

Se fusionan los datos del `shape_municipios` con datos estad√≠sticos del √≠ndice de marginaci√≥n a nivel municipal (`IMM_2020`), excluyendo las claves municipales (`CVE_MUN`) y asegurando que `GM_2020` se ordene de acuerdo a los grados de marginaci√≥n. El resultado es `layer_municipios`, un objeto que contiene a los municipios junto con sus atributos actualizados, lo que facilita su an√°lisis y visualizaci√≥n en mapas.

#### $$SpatialPolygons \Rightarrow SpatialPolygons + Datos$$

```{r, class.source = "fold-show"}
layer_municipios <- merge(shape_municipios,
                           IMM_2020 %>% dplyr::select(c(-CVE_MUN)) %>%
                                         mutate(GM_2020 = fct_relevel(.$GM_2020, "Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")),
                            by = "CVE_GEO")
```

```{r, fig.height=8, fig.width=10, eval = FALSE, class.source = "fold-hide"}
# Paleta de colores 
require(RColorBrewer)
require(ggspatial)
require(ggpubr)

p <- ggplot() + 
      layer_spatial(layer_municipios, aes(fill = IM_2020), color = "transparent") + 
       layer_spatial(shape_estados, fill = "transparent", color = "black") + 
        theme_bw() + 
         theme(plot.title = element_text(size = 22, hjust = 0.15, family = "montserrat", face = "bold"),
               plot.caption = element_text(size = 11, hjust = 0.2, vjust = 1, family = "montserrat"), 
               legend.key.size = unit(0.5, "cm"),
               legend.text = element_text(size = 12, family = "montserrat"), 
               legend.title = element_text(size = 10, hjust = 0.5, family = "montserrat", face = "bold"),
               legend.position = "right"
               ) + 
          scale_fill_viridis_c(option = "A", begin = 0.3, end = 1) +
           scale_color_manual(values = c("#BDBDBD")) + 
            guides(color = guide_legend(override.aes = list(fill = usecol(pal = pal_petrol, n = 5)))) +
     labs(title = "√çndice de marginaci√≥n a nivel municipal, 2020",
           fill = stringr::str_wrap("Grado de marginaci√≥n", 10), 
            caption = expression(paste("Fuentes: Estimaciones del CONAPO con base en el INEGI, Censo de Poblaci√≥n y Vivienda 2020")))
p
path = "Output/Mapa del IMM2020.pdf"
ggexport(p, filename = path ,width = 10, height = 10, device = "cairo")
```


![](../Output/Mapa del IMM2020.png){width="70%" fig-align="center"}


## Centroides

La funci√≥n `coordinates()` extrae las coordenadas de los centroides de los pol√≠gonos en $(x,y)$ de la base de datos espacial y la almacenamos en la variable `coords`, para su posterior uso en el c√≥digo.

```{r}
# Extrayendo coordenadas desde la base de datos espaciales.
coords = coordinates(layer_municipios)
```

## Tipos de distancias

### Reglas de Vecindad en An√°lisis Espacial

Existen dos reglas principales para definir vecindades espaciales:

1.  **Regla de la Reina (Queen Contiguity, `queen = TRUE`)**\

    -   Considera que dos pol√≠gonos son vecinos si **comparten un v√©rtice o un borde**.\

    -   Es m√°s inclusiva y √∫til para an√°lisis de fen√≥menos continuos.

2.  **Regla de la Torre (Rook Contiguity, `queen = FALSE`)**\

    -   Solo considera vecinos a aquellos pol√≠gonos que **comparten un borde completo** (no solo un v√©rtice).

    -   Es m√°s restrictiva y √∫til cuando se analizan estructuras en cuadr√≠culas.

3.  **Estructura de vecindad espacial basada en los** $ùëò- vecinos$ m√°s cercanos.

    -   Este m√©todo usa la distancia euclidiana en el espacio de coordenadas (latitud y longitud) para determinar los $k$ vecinos m√°s cercanos.

**Comparaci√≥n con otros m√©todos de vecindad**

| M√©todo | Criterio de Vecindad | Tipo de Distancia |
|------------------|-----------------------------|-------------------------|
| `poly2nb(..., queen=TRUE)` | Regla de la Reina (borde o v√©rtice) | Topol√≥gica |
| `poly2nb(..., queen=FALSE)` | Regla de la Torre (solo borde) | Topol√≥gica |
| `knn2nb(knearneigh(coords, k))` | $k$ vecinos m√°s cercanos | Euclidiana |

![](../Output/correlaciones.png)

**C√°lculo del m√°ximo n√∫mero de enlaces posibles**

Si hay $n$ municipios, el n√∫mero m√°ximo de conexiones en una red completamente conectada ser√≠a:

$$
    \frac{n \times (n - 1)}{2}
    $$

donde cada municipio se conecta con todos los dem√°s **sin contar conexiones repetidas** (es decir, sin contar dos veces el mismo par de municipios).

Para $n = 2469$ municipios en la red:

$$
    \frac{2469 \times (2469 - 1)}{2} = \frac{2469 \times 2468}{2} = 3,045,846
    $$

Entonces, en una red **completamente conectada**, habr√≠a **3,045,846 enlaces**.

### Queen contiguity

-   `X_nb_queen` almacena la lista de vecinos generada por `poly2nb()` usando la regla de la reina, con el par√°metro `queen = TRUE`.
-   Es un objeto de clase *nb* (neighborhood), que es una estructura que se utiliza para representar relaciones espaciales en an√°lisis de datos espaciales.

```{r}
# Construyendo lista de vecinos con criterio tipo reina
X_nb_queen = poly2nb(layer_municipios, queen = TRUE)  
summary(X_nb_queen)
```

El resultado describe la estructura de vecindad espacial generada usando la regla de la **reina** para los municipios en el objeto `X_nb_queen`. Vamos a desglosarlo:

-   Se indica que hay 14428 enlaces espaciales no nulos entre los municipios. Un enlace no nulo significa que dos municipios son considerados vecinos seg√∫n la regla de la reina (comparten un borde o v√©rtice). En otras palabras, el n√∫mero total de enlaces (14428) es relativamente peque√±o en comparaci√≥n con el n√∫mero total de posibles enlaces (que ser√≠a mucho mayor si cada municipio estuviera conectado con todos los dem√°s municipios).

-   Aproximadamente el 24% de los enlaces posibles entre los municipios son vecinos. Es decir, solo un peque√±o porcentaje de los posibles pares de municipios est√°n conectados por un enlace de vecindad.

-   Cada municipio, en promedio, est√° conectado con aproximadamente 5.84 municipios vecinos. Es decir, la mayor√≠a de los municipios tienen alrededor de 5-6 vecinos, pero hay 3 municipios muy conectados (hasta 22 vecinos) y otros muy aislados (solo un vecino).

**Comparaci√≥n con el resultado actual**

En la red de vecindad (con la regla de la reina), hay **14,428 enlaces**, lo que representa:

$$
    \frac{14,428}{3,045,846} \times 100 = 0.47% 
    $$

Solo **el 0.47% de los enlaces posibles existen**, lo que indica que la red de vecindad es muy **dispersa** en comparaci√≥n con una red completamente conectada.



### Rook contiguity

`X_nb_rook` es una lista de vecindad espacial basada en la regla del torre (Rook Contiguity) en lugar de la regla de la reina, con el par√°metro `queen = FALSE`.

```{r}
# Construyendo lista de vecinos con criterio  tipo torre
X_nb_rook = poly2nb(layer_municipios, queen = FALSE) 
summary(X_nb_rook)
```

üìå En comparaci√≥n con `X_nb_queen`, esta red de vecindad tiene **menos enlaces**, lo que confirma que hay municipios que solo compart√≠an v√©rtices y que ahora no se consideran vecinos.

-   Se indica que hay 14,200 conexiones entre municipios. Es un poco menor que en `X_nb_queen` (14,428 enlaces), lo que indica que se eliminaron enlaces que solo ocurr√≠an en los v√©rtices. 

-   Aproximadamente el 23.29% de los pares posibles de municipios est√°n conectados. Es decir, solo un peque√±o porcentaje de los posibles pares de municipios est√°n conectados por un enlace de vecindad.

-   Cada municipio, en promedio, est√° conectado con aproximadamente 5.75 vecinos por municipio en promedio. Es decir, la mayor√≠a de los municipios tienen alrededor de 5-6 vecinos, pero hab√≠a 3 municipios con 22 enlaces. Ahora, solo hay 1 municipio con 22 enlaces. 
- Esto indica que algunos municipios perdieron conexiones al aplicar la regla del torre, pero el municipio m√°s conectado sigue teniendo el mismo n√∫mero m√°ximo de enlaces.   

En la red de vecindad (con la regla de la torre), hay **14,200 enlaces**, lo que representa:

$$
    \frac{14,200}{3,045,846} \times 100 = 0.46% 
    $$

Solo **el 0.46% de los enlaces posibles existen**, lo que indica que la red de vecindad es muy **dispersa** en comparaci√≥n con una red completamente conectada y menor al utilizar la regla de la torre.


### k-neighbours contiguity  

`X_kn4` se crea una lista de vecinos basada en la proximidad de coordenadas usando el m√©todo de los $k$ vecinos m√°s cercanos (*k*-nearest neighbors, KNN) con $k = 5$.   

```{r}
# Construyendo lista de vecinos con k-vecinos m√°s cercanos
IDs = row.names(as(layer_municipios, "data.frame")) # Id de las filas
X_kn4 = knn2nb(knearneigh(coords, k = 5), row.names = IDs) 
X_kn4
```

-   Se indica que hay 12 345 conexiones entre municipios. - Como se us√≥ \( k = 5 \), cada municipio tiene **exactamente 5 vecinos**, lo que da un total de:  
  \[
    2469 \times 5 = 12 345
    \]
- **A diferencia de `X_nb_queen` o `X_nb_rook`**, donde el n√∫mero de vecinos var√≠a, aqu√≠ **todos tienen exactamente 5 vecinos**.  

-   Aproximadamente el **el 20% de los pares posibles de municipios est√°n conectados**. Es decir, es menor que en `X_nb_queen` (**23.67%**) y `X_nb_rook` (**23.29%**), lo que tiene sentido porque aqu√≠ cada municipio tiene un n√∫mero fijo de vecinos menor que el promedio en los otros m√©todos.

-   Cada municipio, est√° conectado por **5 vecinos por municipio en promedio**. Es decir, esto es **esperado**, ya que en `knn2nb(k = 5)`, cada municipio tiene exactamente 5 vecinos.  

- **En `X_nb_queen` y `X_nb_rook`, el promedio era ~5.8 vecinos** porque depend√≠a de la geometr√≠a de los municipios.

En la red de vecindad (con k - vecinos), hay **12 345 enlaces**, lo que representa:

$$
    \frac{12 345}{3 045 846} \times 100 = 0.40% 
    $$

Solo **el 0.40% de los enlaces posibles existen**, lo que indica que la red de vecindad es muy **dispersa** en comparaci√≥n con una red completamente conectada y menor al utilizar la regla de la reina o torre. 


### **üìä Comparaci√≥n con `X_nb_queen` y `X_nb_rook`**    
  
  
  | M√©todo                           | Vecinos por municipio (promedio) | Total de enlaces | Relaci√≥n sim√©trica |
  |----------------------------------|:------------------------------:|:----------------:|----------------------|
  | Regla de la Reina (`X_nb_queen`) | 5.84                           | 14,428           | ‚úÖ S√≠ | |
  | Regla del Torre (`X_nb_rook`)    | 5.75                           | 14,200           | ‚úÖ S√≠ |
  | KNN con \( k = 4 \) (`X_kn4`)    | 5                              | 12,345            | ‚ùå No |             


```{r, eval = FALSE, class.source = "fold-hide"}
library(ggplot2)
library(sf)
library(spdep)
library(ggspatial)
library(viridis)


#plot(layer_municipios, border = 'lightgrey')
#plot(X_nb_queen, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")

# Se convierten los layer_municipios y centroides a sf (spatial features)
target_crs <- st_crs(layer_municipios) # Extraer CRS original
coords_sf <- st_as_sf(as.data.frame(coords), coords = c("V1", "V2"), crs = target_crs)

# Se obtienen los enlaces de vecinos en formato de l√≠neas
nb_lines <- unlist(
            lapply(1:length(X_nb_queen), function(i) {
              if (length(X_nb_queen[[i]]) > 0) {
                lapply(X_nb_queen[[i]], function(j) {
                  st_linestring(rbind(coords[i, ], coords[j, ]))
                })
              } else {
                NULL
              }
            }), recursive = FALSE
          )

nb_lines_sf <- st_sfc(nb_lines, crs = target_crs)

# Se convierten los enlaces de l√≠neas a un sf object
graph_sf <- st_as_sf(nb_lines_sf, crs = target_crs)

# Crear el gr√°fico
p <- ggplot() +
      layer_spatial(data = shape_estados, fill = "transparent", color = "black") +
       geom_sf(data = graph_sf, color = "#7f7f7f", size = 0.3, alpha = 0.2) +  # L√≠neas de vecinos
        geom_sf(data = coords_sf, color = "#1d6d9c", size = 0.6) +  # Puntos de los municipios
         theme_bw() +
          theme(plot.title = element_text(size = 22, hjust = 0.15, family = "montserrat", face = "bold"),
                plot.subtitle = element_text(size = 20, hjust = 0.15, family = "montserrat", face = "bold"),
                plot.caption = element_text(size = 11, hjust = 0.5, vjust = 1, family = "montserrat"),
                legend.key.size = unit(0.5, "cm"),
                legend.text = element_text(size = 12, family = "montserrat"),
                legend.title = element_text(size = 10, hjust = 0.5, family = "montserrat", face = "bold"),
                legend.position = "right"
                ) +
            labs(title = "Mapa de distancias utilizando la regla de la reina",
                 caption = expression(paste("Fuentes: Elaboraci√≥n propia"))
            )
p

path = paste0(here::here(), "/Output/Mapa de distancias.pdf")
ggexport(p, filename = path ,width = 10, height = 10, device = "cairo")
```

![](../Output/Mapa de distancias.png){width="70%" fig-align="center"}

## Ponderaciones

Construcci√≥n de la matriz de ponderaciones espacial (asignar pesos a las √°reas que est√°n vinculadas). Los pesos espaciales son clave para representar relaciones espaciales, mejorar an√°lisis estad√≠sticos y realizar predicciones m√°s realistas en modelos geoespaciales. 

Para considerar la estructura de vecindad y los efectos espaciales en la estimaci√≥n de los par√°metros se especifica una matriz cuadrada (`W`) denominada matriz de pesos o matriz de ponderaciones, cuyos elementos no negativos dan evidencia de la intensidad de la interdependencia existente entre cada par de unidades geogr√°ficas $i$ y $j$.

`nb2listw` (Pesos espaciales para listas de vecinos): Complementa una lista de vecinos con pesos espaciales para el esquema de codificaci√≥n elegido.

Por defecto, `nb2listw()` asigna **pesos estandarizados por fila (row-standardized weights)**:  
  \[
    w_{ij} = \frac{1}{N_i}
    \]
donde \( N_i \) es el n√∫mero de vecinos del municipio \( i \).  

üìå **Esto significa que la suma de los pesos de cada fila es 1**, lo que ayuda a evitar que municipios con m√°s vecinos dominen el an√°lisis.

---
  
### **üîπ Diferentes Estilos de Pesos**  

Puedes cambiar el estilo de ponderaci√≥n con el argumento `style`:
  
| Estilo (`style`) | Explicaci√≥n |
|------------------|-------------|
| `"B"` (Binario) | 1 si son vecinos, 0 si no lo son |
| `"W"` (Row-standardized, **default**) | Cada peso es \( 1 / N_i \) |
| `"S"` (Suma de filas igual a 1) | Normaliza para evitar sesgos por diferencias en el n√∫mero de vecinos |
| `"U"` (Varianza unitaria) | Pondera para obtener varianza constante en las filas |


Ejemplo en `R`:  

```{r, echo = TRUE, eval = FALSE}
X_nbq_w_bin = nb2listw(X_nb_queen, style = "B")  # Pesos binarios
X_nbq_w_std = nb2listw(X_nb_queen, style = "W")  # Pesos est√°ndar (default)
X_nbq_w_sum = nb2listw(X_nb_queen, style = "S")  # Normalizaci√≥n por suma
```

---
  

### Queen contiguity 

Se convierte `X_nb_queen` en una **lista** (lista de pesos espaciales), que es la estructura que `R` usa en an√°lisis espaciales como **Moran‚Äôs I o modelos espaciales**.


```{r}
#   Matriz de pesos normalizados en fila 
# usando QUEEN(W) (Tipo reina):
X_nbq_w = nb2listw(X_nb_queen)
X_nbq_w
```

### Rook contiguity

Se convierte `X_nb_rook` en una **lista** (lista de pesos espaciales), que es la estructura que `R` usa en an√°lisis espaciales como **Moran‚Äôs I o modelos espaciales**.

```{r}
#   Matriz de pesos normalizados en fila 
# usando ROOK(W) (Tipo torre):
X_nbr_w = nb2listw(X_nb_rook)
X_nbr_w
```
### k-neighbours contiguity

Se convierte `X_kn4` en una **lista** (lista de pesos espaciales), que es la estructura que `R` usa en an√°lisis espaciales como **Moran‚Äôs I o modelos espaciales**.

```{r}
#   Matriz de pesos normalizados en fila usando k = 5(W):
X_kn4_w = nb2listw(X_kn4)
X_kn4_w
```


Resumen estad√≠stico de la matriz de pesos para cada criterio

```{r}
summary(unlist(X_nbq_w$weights))  # Criterio reina
```

```{r}
summary(unlist(X_nbr_w$weights))  # Criterio torre
```

```{r}
summary(unlist(X_kn4_w$weights))  # Criterio k-vecinos
```

## √çndice de Moran:

Evaluando existencia de autocorrelaci√≥n espacial

El **√çndice de Moran** var√≠a entre -1 y 1:   
  - **\( I > 0 \)** indica correlaci√≥n positiva (valores similares est√°n agrupados).   
- **\( I < 0 \)** indica correlaci√≥n negativa (valores diferentes est√°n cercanos entre s√≠).  
- **\( I \approx 0 \)** sugiere ausencia de autocorrelaci√≥n espacial.   

`moran.test`: (Prueba `I de Moran` para autocorrelaci√≥n espacial) Utiliza una matriz de ponderaciones espaciales en forma de lista de ponderaciones. La opci√≥n alternativa especifica la hip√≥tesis alternativa, debe ser mayor (predeterminado), menor o como en este caso, bilateral (`two.side`).  


### Queen contiguity

```{r}
# Regla de la reina:
Ind_Moran_queen = moran.test(layer_municipios$IM_2020, 
                             listw = X_nbq_w, 
                             alternative = "two.side")
Ind_Moran_queen
```


- **Moran I statistic = 0.6465**. Indica una fuerte **autocorrelaci√≥n espacial positiva**. Los municipios con valores altos de `IM_2020` tienden a estar cerca de otros municipios con valores altos, y los municipios con valores bajos tienden a estar cerca de otros municipios con valores bajos.    

- **Expectation = -0.0004**. Es el valor esperado de Moran I bajo la hip√≥tesis nula (aleatoriedad espacial).  Un valor muy cercano a 0, indica que **sin autocorrelaci√≥n, esperar√≠amos valores cercanos a 0**.  

- Significancia estad√≠stica **p-value < 2.2e-16**. Indica que la probabilidad de obtener un Moran I tan alto por azar es **pr√°cticamente 0**. Por lo tanto se rechaza la hip√≥tesis nula, es decir, hay evidencia estad√≠sticamente significativa de autocorrelaci√≥n espacial en `IM_2020`.    

### Rook contiguity

```{r}
# Regla de la torre
Ind_Moran_rook = moran.test(layer_municipios$IM_2020, 
                            listw = X_nbr_w, 
                            alternative = "two.side")
Ind_Moran_rook
```

- **Moran I sigue siendo alto (~0.647 en ambos casos)**.Existe una fuerte **autocorrelaci√≥n espacial positiva**.  
- **El Z-score es similar (~53 en ambos casos)**.La evidencia de autocorrelaci√≥n espacial es estad√≠sticamente significativa.  
- **El p-valor sigue siendo < 2.2e-16**.La autocorrelaci√≥n observada **no es aleatoria**.  


### k-neighbours contiguity

```{r}
# k-veciono con k = 5:
Ind_Moran_k = moran.test(layer_municipios$IM_2020, 
                         listw = X_kn4_w, 
                         alternative = "two.side") 
Ind_Moran_k
```


- **Moran I m√°s alto (0.6605 vs. ~0.646)** ‚Üí Mayor **dependencia espacial entre municipios** cuando se usa k-vecinos.  
- **Z-score m√°s alto (55.253 vs. ~53)** ‚Üí Mayor fuerza estad√≠stica en la relaci√≥n espacial.  
- **p-valor sigue siendo < 2.2e-16** ‚Üí **Autocorrelaci√≥n altamente significativa**, no es aleatoria.  



#### üìä **Resumen de los resultados**  

| Regla de Vecindad | Moran I | Standard Deviate | p-valor |
  |-------------------|---------|------------------|---------|
  | **Queen (X_nbq_w)** | **0.6465** | **53.168** | **< 2.2e-16** |
  | **Rook (X_nbr_w)**  | **0.6469** | **52.78**  | **< 2.2e-16** |
  | **k-Vecinos (k = 5, X_kn4_w)** | **0.6605** | **55.253** | **< 2.2e-16** | 
  

### Moran test  

Tanto `moran()` como `moran.test()` est√°n relacionadas con el c√°lculo del √çndice de Moran I, pero tienen prop√≥sitos distintos.   

Utilizando la funci√≥n `moran()`, calcula Moran I y adem√°s realiza una prueba de hip√≥tesis para determinar si la autocorrelaci√≥n espacial es estad√≠sticamente significativa.

```{r}
Moran_Test <- moran(layer_municipios$IM_2020, listw = X_nbq_w, length(X_nbq_w), Szero(X_nbq_w))
Moran_Test
```

- Indice de Mor√°n, tiene un  **valor obtenido: `0.0007855639`**. Un valor cercano a 0, indica **muy poca o nula autocorrelaci√≥n espacial** en los datos.    

- Factor de normalizaci√≥n **K = 7.847273**. Este valor es **un factor de normalizaci√≥n** utilizado en c√°lculos internos de Moran I. No tiene una interpretaci√≥n directa, pero se usa para estandarizar el resultado. 


Recordemos La autocorrelaci√≥n espacial positiva se presenta cuando valores altos [bajos] de la variable de estudio en una localizaci√≥n est√°n asociados con valores altos [bajos] en las regiones vecinas. De manera que la tasa de pobreza en los diferentes puntos se va a presentar de forma similar y esto afirma la posible existencia de cl√∫steres.


### Prueba del estad√≠stico I de Moran

Se calcula un pseudo `p-value` determinando, la proporci√≥n de los valores I de Moran local generados a partir de permutaciones que muestran m√°s agrupaciones que los datos originales. Si esta proporci√≥n (el pseudo valor p) es peque√±a (menos de 0.05), puede concluir que sus datos muestran agrupaciones estad√≠sticamente significativas.

`moran.mc`: Realiza una prueba de permutaci√≥n de Monte Carlo para evaluar la significancia estad√≠stica del √çndice de Moran I. Esto es √∫til para confirmar si la autocorrelaci√≥n espacial observada es real o podr√≠a haber ocurrido por azar.

#### Queen contiguity

```{r}
moran.mc(layer_municipios$IM_2020, listw = X_nbq_w, nsim = 1000) # Reina
```
-  `statistic = 0.64652` (√çndice de Moran I observado)** el valor es **positivo y alto (~0.5 - 1)**, indica una **fuerte autocorrelaci√≥n espacial positiva**. Esto significa que **los municipios con valores similares del √≠ndice IM_2020 tienden a agruparse en el espacio geogr√°fico**.  

- Si el valor fuera cercano a 0, no habr√≠a autocorrelaci√≥n espacial, y si fuera negativo, los valores dis√≠miles estar√≠an dispersos.    
- **`p-value = 0.001` (Nivel de significancia estad√≠stica)**. Como el `p-value` es **menor que 0.05**, rechazamos la hip√≥tesis nula de que **la autocorrelaci√≥n espacial observada es producto del azar**. En otras palabras, **existe una agrupaci√≥n espacial significativa de municipios con valores similares de IM_2020**.   

#### Rook contiguity

```{r}
moran.mc(layer_municipios$IM_2020, listw = X_nbr_w, nsim  =1000) # Torre
```

- El **p-valor es menor que 0.05**, lo que indica que la autocorrelaci√≥n espacial observada **no es aleatoria**. Espec√≠ficamente, como `p < 0.001`, podemos decir que **la evidencia de autocorrelaci√≥n espacial es extremadamente fuerte**.  

- **Valor:** `0.64693.  Como el **valor del estad√≠stico es positivo y alto (~0.5 - 1)**, indica **fuerte autocorrelaci√≥n espacial positiva**.  Esto significa que **los municipios con valores similares de IM_2020 tienden a agruparse cuando se usa la vecindad tipo torre**.    


#### k-neighbours contiguity

```{r}
moran.mc(layer_municipios$IM_2020, listw = X_kn4_w, nsim = 1000) # K-vecinos
```
- El estad√≠stico de Moran I: 066055, sigue siendo **positivo y alto (~0.5 - 1)**, lo que indica **una fuerte autocorrelaci√≥n espacial positiva**.  En este caso, el √≠ndice **es a√∫n mayor** que con las reglas de la reina (`0.64652`) y la torre (`0.64693`), lo que sugiere **una mayor concentraci√≥n espacial de valores similares** bajo esta definici√≥n de vecindad.  
- Esto puede deberse a que la regla de k-vecinos **incluye siempre exactamente 5 vecinos**, independientemente de la geograf√≠a y los l√≠mites administrativos.  


Dado que el p-value para cada m√©todo o criterio es igual a 0.001, y este valor es menor a 0.05, significa que se muestran agrupaciones estad√≠sticamente significativas.  


### üìå Comparaci√≥n entre m√©todos de vecindad

| Vecindad | Moran I | p-valor |
|----------|---------|---------|
| **Reina** (queen) | 0.64652 | `< 0.001` |
| **Torre** (rook) | 0.64693 | `< 0.001` |
| **k-vecinos (k=5)** | 0.66055 | `< 0.001` |
  
  
## Prueba C de Geary:  

El test de Geary: `C` es una prueba estad√≠stica utilizada para evaluar la **autocorrelaci√≥n espacial** en los datos. Mientras que el **√çndice de Moran I** mide la **autocorrelaci√≥n global** (es decir, si los valores de una variable se agrupan o dispersan en todo el espacio), el `Geary C` se centra en las diferencias locales entre vecinos. 


El √≠ndice de Geary (`C`) es un √≠ndice de comparaciones por pares entre las diferentes zonas; por lo general var√≠a entre 0 y 2. 

El **valor de** $C$ var√≠a entre $0$ y $2$:

\- $C \approx 1$ indica independencia espacial (ausencia de correlaci√≥n).

\- $C < 1$ sugiere autocorrelaci√≥n espacial positiva (valores similares est√°n cerca).

\- $C > 1$ indica autocorrelaci√≥n espacial negativa (valores diferentes est√°n cercanos entre s√≠).


`geary.test`: (Prueba `C` de Geary para autocorrelaci√≥n espacial).Utiliza una matriz de ponderaciones espaciales en forma de lista de ponderaciones. La opci√≥n alternativa especifica la hip√≥tesis alternativa, debe ser mayor (predeterminado), menor o como en este caso, bilateral (two.side).

### Queen contiguity

```{r}
# Regla de la reina:
geary.test(layer_municipios$IM_2020, listw = X_nbq_w, alternative = "two.side")
```

- **Valor:** `0.35505`.  El valor de **Geary C** **cerca de 0** indica **una fuerte autocorrelaci√≥n espacial positiva**, ya que **valores cercanos a 0** sugieren que los valores similares est√°n m√°s agrupados entre los vecinos. En t√©rminos generales, este valor es **significativamente bajo**, lo que indica una tendencia a m√°s similitud espacial entre los municipios vecinos.

- El **p-value es extremadamente bajo (< 2.2e-16)** (mucho menor que 0.05) indicando que se puede **rechazar la hip√≥tesis nula** de que no hay autocorrelaci√≥n espacial. Es decir, sugiere que los valores de IM_2020 est√°n agrupados espacialmente de manera significativa, con municipios cercanos que muestran un comportamiento similar en cuanto al valor de IM_2020.


### Rook contiguity

```{r}
# Regla de la torre
geary.test(layer_municipios$IM_2020, listw = X_nbr_w, 
                             alternative = "two.side")
```

- El valor de **Geary C (`0.35505`) es considerablemente bajo**, lo que indica que los valores de `IM_2020` se agrupan m√°s de lo que se esperar√≠a por azar.
- El **p-valor extremadamente bajo (< 2.2e-16)** sugiere que **esta agrupaci√≥n espacial es altamente significativa**. Esto refuerza la idea de que los municipios con valores similares en IM_2020 est√°n agrupados** en el espacio y que esta agrupaci√≥n es **significativa**.



### k-neighbours contiguity  

```{r}
# k-vecinos, k = 5:
geary.test(layer_municipios$IM_2020, listw = X_kn4_w, 
                         alternative = "two.side") 
```

- **El test de Geary C con k-vecinos (k = 5)** confirma la presencia de **autocorrelaci√≥n espacial positiva** en los datos de `IM_2020`.
- El valor de **Geary C (`0.32368`) es a√∫n m√°s bajo** que en los an√°lisis anteriores (Reina y Torre), lo que indica que **hay una agrupaci√≥n espacial m√°s fuerte** bajo la vecindad de **k-vecinos**.
- El **p-valor extremadamente bajo (< 2.2e-16)** sugiere que **la autocorrelaci√≥n espacial es altamente significativa**.



### Comparaci√≥n entre las tres definiciones de vecindad:   
- **Vecindad de Reina (queen):** `Geary C = 0.35505`
- **Vecindad de Torre (rook):** `Geary C = 0.35505`
- **k-vecinos (k = 5):** `Geary C = 0.32368`


### Prueba del estad√≠stico C de geary  

- **`geary.test()`**: Basado en aproximaciones asint√≥ticas, puede ser m√°s r√°pido pero menos flexible en ciertas situaciones.

- **`geary.mc()`**: Utiliza simulaciones y es m√°s **robusto** y **preciso**, especialmente en presencia de distribuciones no normales o datos at√≠picos.

#### Queen contiguity 

```{r}
geary.mc(layer_municipios$IM_2020, listw = X_nbq_w, nsim = 999) # Reina
```

- El test de **Geary C usando simulaciones de Monte Carlo** indica que hay una **autocorrelaci√≥n espacial positiva significativa** en los datos de `IM_2020` para los municipios.
- **El valor observado de Geary C (0.35579)** es mucho **m√°s bajo** que el valor esperado bajo la hip√≥tesis nula, lo que significa que los municipios cercanos tienen **valores m√°s similares** en comparaci√≥n con lo que ser√≠a esperado aleatoriamente.
- El **p-valor (0.001)** es **muy peque√±o**, lo que confirma que esta autocorrelaci√≥n es significativa.
- El **ranking de 1** tambi√©n sugiere que el valor observado es **m√°s bajo** que en todas las simulaciones aleatorias generadas.



#### Rook contiguity 

```{r}
geary.mc(layer_municipios$IM_2020, listw = X_nbr_w, nsim = 999) # Torre
```

 - El test de **Geary C usando simulaciones de Monte Carlo** muestra que hay una **autocorrelaci√≥n espacial positiva significativa** en los valores de `IM_2020` de los municipios, es decir, los municipios cercanos tienen **valores similares** en comparaci√≥n con lo que ser√≠a esperado por azar.
- El valor observado de **Geary C (0.35505)** es **m√°s bajo** que lo esperado bajo la hip√≥tesis nula, lo que refuerza la presencia de **autocorrelaci√≥n espacial positiva**.
- El **p-valor (0.001)** es **muy peque√±o**, lo que indica que la autocorrelaci√≥n observada es **estad√≠sticamente significativa**.
- El **ranking de 1** sugiere que el valor observado es **el m√°s bajo** entre las simulaciones, lo que significa que la **agregaci√≥n espacial de los valores** es mucho mayor de lo que ser√≠a aleatorio.



#### k-neighbours contiguity 

```{r}
geary.mc(layer_municipios$IM_2020, listw = X_kn4_w, nsim = 999) # K-vecinos
```

- El test de **Geary C utilizando simulaciones de Monte Carlo** con la configuraci√≥n de **k-vecinos (k=4)** muestra que existe una **autocorrelaci√≥n espacial positiva significativa** entre los valores de `IM_2020` de los municipios.
- El valor observado de **Geary C (0.32368)** es **bajo**, lo que indica que los municipios cercanos tienen **valores similares** en `IM_2020`, lo que implica una **autocorrelaci√≥n espacial positiva**.
- El **p-valor (0.001)** es **muy peque√±o**, lo que significa que la **autocorrelaci√≥n observada es estad√≠sticamente significativa**.
- El **ranking de 1** sugiere que el valor observado de **Geary C** es **el m√°s bajo** entre las simulaciones, lo que indica que los valores son m√°s **similares** de lo que ser√≠a esperado si no existiera autocorrelaci√≥n.



Dado que el p-value para cada m√©todo o criterio es igual a 0.001, y este valor es menor a 0.05, significa que se muestran agrupaciones estad√≠sticamente significativas.

### Prueba G(d) de Getis y Ord

- **`geary.mc()`**: Es m√°s √∫til para detectar **autocorrelaci√≥n local** y analizar c√≥mo las diferencias entre valores cercanos se comportan. Est√° m√°s orientado a evaluar c√≥mo se distribuyen los valores en relaci√≥n con sus vecinos cercanos. Se usa generalmente cuando se quiere analizar si las **valores cercanos** son m√°s similares o m√°s dispersos entre s√≠.

- **`globalG.test()`**: Es adecuado cuando se quiere evaluar la presencia de **agrupamientos espaciales globales** en un √°rea geogr√°fica, es decir, ver si hay **agrupamientos significativos de valores extremos (altos o bajos)** en todo el espacio. Se usa cuando el inter√©s es encontrar **puntos calientes o fr√≠os** dentro de la regi√≥n geogr√°fica.

#### k-neighbours contiguity

```{r}
# Ahora, usando k = 5:
globalG.test(layer_municipios$IM_2020, listw = X_kn4_w, alternative = "two.side") 
```

- Dado que el **p-valor es extremadamente bajo (< 2.2e-16)**, se **rechaza la hip√≥tesis nula** y se concluye que **hay una agrupaci√≥n espacial significativa** de los valores en el conjunto de datos. 
- Sin embargo, el valor del **Global G observado** (cercano a cero) sugiere que no existe una **concentraci√≥n fuerte de valores altos o bajos**. Este valor cercano a cero indica que los valores **no est√°n fuertemente agrupados** en √°reas de valores extremos (como puntos calientes o fr√≠os), pero a√∫n as√≠, la estructura espacial **no es aleatoria**, lo que podr√≠a sugerir un patr√≥n d√©bil de agrupaci√≥n.  

  

## Gr√°fico de dependencia espacial

Un gr√°fico de dispersi√≥n que permite analizar la autocorrelaci√≥n espacial global, es el denominado **Scatterplot de Moran univariante (Anselin, 1993)** . Este gr√°fico se construye en un plano cartesiano, en el eje de abscisas se ubican los valores de la variable de estudio estandarizada (x), y en el eje de ordenadas, se ubican los valores del retardo espacial de la variable estandarizada. 

- Si la nube de puntos tiende a formarse sobre la diagonal principal del plano cartesiano (cuadrante I y III, en contra de las manecillas de reloj), esto nos indicar√° la presencia de autocorrelaci√≥n espacial positiva.

- Si la nube de puntos tiende a ubicarse sobre la diagonal secundaria del plano cartesiano (cuadrante II y IV, en contra de las manecillas de reloj) , ser√° un indicio de existencia de autocorrelaci√≥n espacial negativa.

- De lo contrario, si la nube de puntos de distribuye sobre los cuatro cuadrantes, esto nos indicar√° ausencia de autocorrelaci√≥n espacial.

![](../Output/cuadrantes.png){width="50%" fig-align="center"}

Utilizando la funci√≥n `moran.plot` perite generar una gr√°fica de datos espaciales frente a sus valores espaciales rezagados,  al informar el resumen de las medidas de influencia para la relaci√≥n lineal entre los datos y el rezago.


```{r, fig.height=5, fig.width=7, eval = TRUE, class.source = "fold-hide"}
require(ggrepel)

mp <- moran.plot(layer_municipios$IM_2020, 
                 listw = X_kn4_w, 
                 main = "Scatterplot de Moran para la pobreza", 
                 labels = unique(IMM_2020$CVE_MUN), 
                 plot = FALSE)

ggplot(mp, aes(x = x, y = wx)) + 
 geom_point(shape = 1, 
            color = "#0e4669", 
            alpha = 0.5) + 
  geom_smooth(formula = y ~ x, method = "loess") + 
   geom_smooth(formula = y ~ x, 
               method = "lm", 
               se = FALSE, 
               colour = "lightblue") + 
     geom_hline(yintercept = mean(mp$wx), lty = 2) + 
      geom_vline(xintercept = mean(mp$x), lty = 2) + 
       geom_point(data = mp[mp$is_inf,], aes(x = x, y = wx), shape = 9, color = "#777777") +
        geom_text_repel(data = mp[mp$is_inf,], 
                         aes(x = x, 
                             y = wx, 
                             label = labels, 
                             vjust = 1.5)) +
         theme_bw() + 
          theme(plot.title = element_text(size = 22, hjust = 0, family = "montserrat", face = "bold"),
                plot.caption = element_text(size = 11, hjust = 0.2, vjust = 1, family = "montserrat"), 
                text = element_text(family = "montserrat"), 
                legend.key.size = unit(0.5, "cm"),
                legend.text = element_text(size = 12, family = "montserrat"), 
                legend.title = element_text(size = 10, hjust = 0.5, family = "montserrat", face = "bold"),
                legend.position = "none"
               ) +   
         labs(title = "Gr√°fico de dependencia espacial",
              subtitle = "√çndice de marginaci√≥n a nivel municipal",
              y = "Rezago espacial de los municipios",
              x = "Municipios")


```


Dado que la nube de puntos tiende a formarse sobre la diagonal principal del plano cartesiano (cuadrante I y III), esto indica la presencia de autocorrelaci√≥n espacial positiva.

## Indicador Local de Autocorrelaci√≥n Espacial (LISA):

Anselin (1995) se refiri√≥ a esto como una estad√≠stica ‚ÄúLISA‚Äù, El **Indicador Local de Autocorrelaci√≥n Espacial (LISA)** permite identificar la **autocorrelaci√≥n espacial** a nivel local, es decir, en qu√© medida una unidad espacial (por ejemplo, municipio o vecindad) est√° asociada a sus vecinos cercanos en t√©rminos de alguna variable de inter√©s. El c√°lculo de LISA se puede realizar con el paquete `spdep` en R.


`localmoran`: La estad√≠stica local espacial I de Moran se calcula para cada zona en funci√≥n del objeto de ponderaciones espaciales.

`lag.listw`: Usando una representaci√≥n dispersa de listw de una matriz de ponderaciones espaciales, calcula el vector de retardo. 

```{r, fig.height=6, fig.width=8, eval = FALSE, class.source = "fold-hide"}
# Calcular LISA usando localmoran()
LISA_result <- localmoran(layer_municipios$IM_2020, X_nbq_w)

# Agregar los resultados de LISA al objeto espacial
layer_municipios <- layer_municipios %>% 
                     mutate(LISA = LISA_result[,1]) 

p <-  ggplot() +
       layer_spatial(layer_municipios, aes(fill = LISA), color = "transparent") + 
        layer_spatial(shape_estados, fill = "transparent", color = "black") + 
         scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) +
          theme_bw() + 
           theme(plot.title = element_text(size = 20, hjust = 0, family = "montserrat", face = "bold"),
                 plot.subtitle = element_text(size = 16, hjust = 0, family = "montserrat"),
                 plot.caption = element_text(size = 11, hjust = 0.2, vjust = 1, family = "montserrat"), 
                 legend.key.size = unit(0.5, "cm"),
                 legend.text = element_text(size = 9, family = "montserrat"), 
                 legend.title = element_text(size = 10, hjust = 0.5, family = "montserrat", face = "bold"),
                 legend.position = "right"
                   ) + 
            labs(title = "LISA: Local Moran's I", 
                 subtitle = "√çndice de marginaci√≥n a nivel municipal, 2020",
                 fill = "LISA Value",
                 caption = expression(paste("Fuentes: Estimaciones del CONAPO con base en el INEGI, Censo de Poblaci√≥n y Vivienda 2020")))
 
path = "Output/Mapa de LISA.pdf"
ggexport(p, filename = path ,width = 10, height = 10, device = "cairo")
```
![](../Output/Mapa de LISA.png){width="70%" fig-align="center"}

### Cluster map 

```{r, fig.height=6, fig.width=8, eval = FALSE, class.source = "fold-hide"}
LISA_result <- localmoran(layer_municipios$IM_2020, listw = X_nbq_w)

layer_municipios@data  <- layer_municipios@data %>% 
                            mutate(pvalue = LISA_result[,5],
                                   cX = .$IM_2020 - mean(IM_2020)) %>% # IM - Media(IM) 
                             mutate(lagDV = lag.listw(X_nbq_w, .$IM_2020)) %>% # Calcula el rezago (promedios)
                              mutate(clagDV = .$lagDV - mean(lagDV)) %>% # Rezago - Media(Rezago)
                               mutate(quadrant = case_when(.$cX > 0 & .$clagDV > 0 & .$pvalue <= 0.05 ~ "Alto-Alto", 
                                                           .$cX < 0 & .$clagDV < 0 & .$pvalue <= 0.05 ~ "Bajo-Bajo",
                                                           .$cX < 0 & .$clagDV > 0 & .$pvalue <= 0.05 ~ "Bajo-Alto",
                                                           .$cX > 0 & .$clagDV < 0 & .$pvalue <= 0.05 ~ "Alto-Bajo") 
                                      ) %>% 
                                mutate(quadrant = fct_relevel(.$quadrant, c("Alto - Alto", "Bajo - Bajo", "Bajo - Alto", "Alto - Bajo")))
           
p <- ggplot() +
      layer_spatial(layer_municipios, aes(fill = quadrant), color = "transparent") + 
       layer_spatial(shape_estados, fill = "transparent", color = "black") + 
        scale_fill_manual(values = pals::brewer.rdbu(4),  na.value = "transparent") +
         theme_bw() + 
          theme(plot.title = element_text(size = 20, hjust = 0, family = "montserrat", face = "bold"),
                plot.subtitle = element_text(size = 16, hjust = 0, family = "montserrat"),
                plot.caption = element_text(size = 11, hjust = 0.2, vjust = 1, family = "montserrat"), 
                legend.key.size = unit(0.5, "cm"),
                legend.text = element_text(size = 9, family = "montserrat"), 
                legend.title = element_text(size = 10, hjust = 0.5, family = "montserrat", face = "bold"),
                legend.position = "right"
                   ) + 
          labs(title = "LISA Cluster Map", 
               subtitle = "√çndice de marginaci√≥n a nivel municipal, 2020",
               fill = "LISA Value",
               caption = expression(paste("Fuentes: Estimaciones del CONAPO con base en el INEGI, Censo de Poblaci√≥n y Vivienda 2020")))

path = "Output/Mapa de clusters.pdf"
ggexport(p, filename = path, width = 10, height = 10, device = "cairo")
```

![](../Output/Mapa de clusters.png){width="70%" fig-align="center"}


## Referencias

Anselin, L. (1995). Local Indicators of Spatial Association‚ÄîLISA. Geographical Analysis, 27(2), 93‚Äì115.

Datos Abiertos de M√©xico - √çndice de marginaci√≥n (carencias poblacionales) por localidad, municipio y entidad. (2021). Retrieved February 13, 2022, from <https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad>

Bivand, R. S., Pebesma, E., & G√≥mez-Rubio, V. (2013). Applied Spatial Data Analysis with R (2nd ed.). Springer.

RPubs - Spatial Clustering of Univariate Geographically Referenced Attribute. (2020). Retrieved January 30, 2025, from <https://rpubs.com/erikaaldisa/spatialclustering>


## Librer√≠as

**Librer√≠as que se usaron en el trabajo** 

```{r, collapse=FALSE}
sesion_info <- devtools::session_info()
```

```{r, echo = FALSE}
kable(dplyr::select(tibble::as_tibble(sesion_info$packages %>% dplyr::filter(attached == TRUE)),
                    c(package, loadedversion, source))) %>%
   kable_classic(full_width = TRUE, html_font = "montserrat", font_size = 10) 
```

<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/88x31.png" alt="Creative Commons Licence" style="border-width:0"/></a><br />This work by [**Diana Villasana Ocampo**]{xmlns:cc="http://creativecommons.org/ns#" property="cc:attributionName"} is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.

