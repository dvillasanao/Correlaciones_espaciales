---
title: "An√°lisis estad√≠stico espacial"
subtitle: "Utilizando el √≠ndice de marginaci√≥n a nivel municipal"
author: "Diana Villasana Ocampo"
knit: (function(inputFile, encoding) {
       rmarkdown::render(inputFile, encoding = encoding, output_dir = "../Output/")
  })
output:
   html_document:
      code_folding: hide
      highlight: tango
      theme: flatly
      toc: true
      toc_depth: 3
      toc_float:
        collapsed: yes
---

```{=html}
<style type="text/css">
body {
text-align: justify;
font-style: normal;
font-family: "Montserrat";
font-size: 12px
}
h1.title {
  font-size: 40px;
  color: #000D3B;
}
h1 {
  color: #B6854D;
}
h2 {
  color: #172984;
}
h3 {
  color: #172984;
}
</style>
```

```{=html}
<style>
.nav>li>a {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #1C3BA4
}
.nav-pills>li.active>a, .nav-pills>li.active>a:hover, .nav-pills>li>a:focus {
    color: #ffffff;
    background-color: #09C2BC
}
</style>
```

```{=html}
<style>
.tile1-text {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #0A6A87;
    list-style: none;
}
.top1-tiles a:nth-of-type(1):hover, .top-tiles1 a:nth-of-type(1):focus{
    color: #ffffff;
    background: #0A6A87
}
</style>
```

```{=html}
<style>
.tile2-text {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #0A6CC8;
    list-style: none;
}
.top2-tiles a:nth-of-type(1):hover, .top2-tiles a:nth-of-type(1):focus{
    color: #ffffff;
    background: #0A6CC8
}
</style>
```

```{=html}
<style>
.math {
  font-size: 15px;
  color: #B6854D;
}
</style>
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE, 
                      cache.lazy = FALSE, class.source = "fold-show")
knitr::opts_knit$set(root.dir = here::here())
setwd(here::here())
```

```{r,echo=FALSE, eval=FALSE}
rm(list = ls())
```

```{r, echo = FALSE, results=FALSE}
# Paquetes que se usaron en el documento 
require(dplyr)          #A Grammar of Data Manipulation 
require(forcats)        #Tools for Working with Categorical Variables (Factors)
require(ggplot2)        # Generar gr√°ficos ggplot y la geometr√≠a de un mapa
require(ggthemes)       # Extra Themes, scale and Geoms for ggplot2
require(ggmap)          #Spatial Visualization with ggplot2 
require(ggpubr)         # Based Publication Ready Plots with ggplot2
require(ggimage)        # Plot images
require(grDevices)      # Read vector files .svg
require(knitr)
require(kableExtra)
require(lubridate)
library(maptools)
require(openxlsx)
require(readxl)
require(RColorBrewer)   #ColorBrewer Palettes 
require(rgdal)          #Para importar shapefiles. 
require(sp)             # Classes and Methos for Spatial Data
library(spdep)    # √çndice de Moran 
require(spdplyr)        #Data manipulation verbs for the sptial classes
require(tidyverse) 
require(tmap)
require(tmaptools)
require(tibble)
require(unikn)          # Paleta de colores
require(viridisLite)    # Paleta de colores
```

```{r, echo = FALSE, results=FALSE}
# Se descargan las fuentes de la google fonts
require(showtext)
# activar showtext
showtext_auto()
font_add_google("Montserrat", "montserrat")
```

## Objetivo

El an√°lisis espacial es un conjunto de t√©cnicas y herramientas utilizadas para estudiar y comprender patrones, relaciones y procesos geogr√°ficos en un contexto espacial. Es decir, se enfoca en c√≥mo los datos se distribuyen en el espacio y c√≥mo se relacionan entre s√≠, en el c√∫al se utilizan t√©cnicas como el mapeo, estad√≠stica espacial, sistemas de informaci√≥n geogr√°fica (`SIG`)` y la visualizaci√≥n para examinar los datos geogr√°ficos y descubrir patrones y relaciones en ellos.

Estas t√©cnicas permiten la detecci√≥n de patrones y tendencias, la evaluaci√≥n de la accesibilidad y la conectividad, la modelizaci√≥n de procesos geogr√°ficos y la planificaci√≥n y toma de decisiones basadas en la informaci√≥n geogr√°fica. La cuales sirven como ayuda para campos, como la geograf√≠a, planificaci√≥n urbana, epidemiolog√≠a, gesti√≥n de recursos naturales, criminolog√≠a y arqueolog√≠a, entre otros.

## Correlaciones espaciales

Las correlaciones espaciales permiten analizar la relaci√≥n entre variables geogr√°ficas considerando su distribuci√≥n en el espacio. A diferencia de las correlaciones tradicionales, que suponen independencia entre observaciones, las correlaciones espaciales reconocen que valores cercanos tienden a estar m√°s relacionados que aquellos m√°s alejados, fen√≥meno conocido como autocorrelaci√≥n espacial. Este tipo de an√°lisis es fundamental en estudios de patrones geogr√°ficos, como la distribuci√≥n de la pobreza, el acceso a servicios o la din√°mica migratoria, y se mide com√∫nmente mediante indicadores como el `√≠ndice de Moran` o la `estad√≠stica de Geary`. Su aplicaci√≥n ayuda a identificar clusters espaciales, entender din√°micas territoriales y mejorar la toma de decisiones en pol√≠ticas p√∫blicas y planificaci√≥n urbana.

El c√°lculo de la correlaci√≥n espacial se basa en la relaci√≥n entre los valores de una variable y su distribuci√≥n geogr√°fica. Los m√©todos m√°s utilizados son el **√çndice de Moran** y la **estad√≠stica de Geary**, que cuantifican la autocorrelaci√≥n espacial en diferentes escalas.

### 1. √çndice de Moran ($I$)

El **√çndice de Moran** mide la autocorrelaci√≥n espacial global, es decir, qu√© tan similar es una variable en funci√≥n de su ubicaci√≥n. Se calcula como:

$$
I = \frac{N}{W} \times \frac{\sum_{i} \sum_{j} w_{ij} (x_i - \bar{x})(x_j - \bar{x})}{\sum_{i} (x_i - \bar{x})^2}, \quad D : \left\{x \in [-1, 1] \right\}
$$

donde:

\- $N$ es el n√∫mero total de observaciones,

\- $x_i$ y $x_j$ son los valores de la variable en las ubicaciones $i$ y $j$,

\- $\bar{x}$ es la media de la variable,

\- $w_{ij}$ es la matriz de pesos espaciales que define la relaci√≥n entre ubicaciones (por ejemplo, vecindad contigua o distancia),

\- $W$ es la suma de todos los pesos espaciales.

El **√çndice de Moran** var√≠a entre $-1$ y $1$:

\- $I > 0$ indica correlaci√≥n positiva (valores similares est√°n agrupados).

\- $I < 0$ indica correlaci√≥n negativa (valores diferentes est√°n cercanos entre s√≠).

\- $I \approx 0$ sugiere ausencia de autocorrelaci√≥n espacial.

### 2. Estad√≠stica de Geary ($C$)

La estad√≠stica de Geary tambi√©n mide autocorrelaci√≥n espacial, pero es m√°s sensible a las diferencias locales. Se calcula como:

$$
C = \frac{(N-1)}{2W} \times \frac{\sum_{i} \sum_{j} w_{ij} (x_i - x_j)^2}{\sum_{i} (x_i - \bar{x})^2}
$$

donde los t√©rminos son los mismos que en el √çndice de Moran.

El **valor de** $C$ var√≠a entre $0$ y $2$:

\- $C \approx 1$ indica independencia espacial (ausencia de correlaci√≥n).

\- $C < 1$ sugiere autocorrelaci√≥n espacial positiva (valores similares est√°n cerca).

\- $C > 1$ indica autocorrelaci√≥n espacial negativa (valores diferentes est√°n cercanos entre s√≠).

### 3. Estad√≠stica de Getis-Ord ($G_i^*$)

La estad√≠stica de **Getis-Ord** $G_i^*$ es una medida local de autocorrelaci√≥n espacial que identifica clusters de valores altos o bajos en una distribuci√≥n geogr√°fica. Se usa principalmente para detectar **zonas calientes ("hot spots") y zonas fr√≠as ("cold spots")**, lo que la hace √∫til en an√°lisis de crimen, salud p√∫blica, econom√≠a y planificaci√≥n urbana.

#### F√≥rmula de Getis-Ord $G_i^*$:

$$
G_i^* = \frac{\sum_{j} w_{ij} x_j}{\sum_{j} x_j}
$$

donde:\
- $x_j$ es el valor de la variable en la ubicaci√≥n $j$,

\- $w_{ij}$ es el peso espacial entre las ubicaciones $i$ y $j$,

\- $\sum_{j} x_j$ es la suma total de la variable en todas las ubicaciones.

Para interpretar los resultados, se suele estandarizar $G_i^*$ en forma de una puntuaci√≥n $Z$:

$$
Z(G_i^*) = \frac{\sum_j w_{ij} x_j - \bar{X} W_i}{S}
$$

donde:

\- $\bar{X}$ es la media de la variable en toda el √°rea de estudio,

\- $W_i$ es la suma de los pesos espaciales para la ubicaci√≥n $i$,

\- $S$ es la desviaci√≥n est√°ndar de la variable en la regi√≥n.

#### Interpretaci√≥n de $G_i^*$:

-   $Z(G_i^*) > 1.96$ (p \< 0.05) ‚Üí Indica un **hot spot** (zona con valores altos agrupados significativamente).\
-   $Z(G_i^*) < -1.96$ (p \< 0.05) ‚Üí Indica un **cold spot** (zona con valores bajos agrupados significativamente).\
-   $Z(G_i^*) \approx 0$ ‚Üí No hay patrones espaciales significativos.

#### **Diferencia con el √çndice de Moran:**

-   **Moran‚Äôs I** mide la autocorrelaci√≥n espacial **global**, indicando si los valores est√°n agrupados en toda la regi√≥n.\
-   **Getis-Ord** $G_i^*$ detecta **clusters locales**, permitiendo identificar √°reas espec√≠ficas con concentraciones altas o bajas.

#### **Aplicaciones:**

-   En criminolog√≠a, para encontrar **zonas de alta delincuencia**.\
-   En epidemiolog√≠a, para detectar **zonas con alta incidencia de enfermedades**.\
-   En econom√≠a, para analizar **concentraciones de riqueza o pobreza**.\
-   En urbanismo, para identificar **√°reas de crecimiento acelerado o deterioro urbano**.

Esta estad√≠stica es ampliamente utilizada en **Sistemas de Informaci√≥n Geogr√°fica (SIG)** y est√° implementada en software como **ArcGIS, GeoDa y R** (paquetes `spdep` y `sf`).

## Marco Geoestad√≠stico Nacional (MGN) 2020

El **Marco Geoestad√≠stico Nacional (MGN) 2020** del **Instituto Nacional de Estad√≠stica y Geograf√≠a (INEGI)** es un sistema de referencia geogr√°fica que define la divisi√≥n territorial de M√©xico para la recopilaci√≥n, an√°lisis y presentaci√≥n de informaci√≥n estad√≠stica. Se utiliza principalmente en censos y encuestas para garantizar la compatibilidad de datos espaciales a nivel nacional.

#### **Caracter√≠sticas principales del MGN 2020:**

1.  **Unidades geogr√°ficas:**
    -   **√Åreas Geoestad√≠sticas Estatales (AGEE):** corresponden a los estados.\
    -   **√Åreas Geoestad√≠sticas Municipales (AGEM):** coinciden con los municipios.\
    -   **√Åreas Geoestad√≠sticas B√°sicas (AGEB):** subdivisiones de los municipios, utilizadas en zonas urbanas y rurales.\
    -   **Manzanas geoestad√≠sticas:** delimitaciones dentro de las AGEB urbanas.
2.  **Proyecci√≥n y sistema de coordenadas:**
    -   Utiliza el **Sistema de Referencia Geod√©sico ITRF2008** en coordenadas geogr√°ficas con el **datum WGS84**.\
    -   Se presenta en formato vectorial compatible con SIG (Sistemas de Informaci√≥n Geogr√°fica), en formatos como **Shapefile (SHP)** y **GeoJSON**.

#### Shapefile

La funci√≥n `readOGR` del paquete `rgdal`, extrae autom√°ticamente la informaci√≥n utilizada por otros paquetes `SIG` de c√≥digo abierto como QGIS y permite a R manejar una gama m√°s amplia de formatos de datos espaciales. Esta funci√≥n lee datos `OGR` y datos vectoriales, pero solamente permite manejar capas con caracter√≠sticas geom√©tricas (no mezcla puntos, l√≠neas o pol√≠gonos en una sola capa) y a su vez establecer√° un sistema de referencia espacial si la capa tiene dichos metadatos.\
Para leer un archivo `shapefile`, se establecen los siguientes argumentos, como `dsn`, en donde se indica el directorio que contiene los shapes y `layer` que es el nombre expl√≠cito de la capa a trabajar y dichas capas deben de ir sin la extensi√≥n `.shp`.

A continuaci√≥n, se lee el archivo .shp que contiene de manera integrada la divisi√≥n de el √°rea geoestad√≠stica municipal `agem`.

```{r,results=FALSE,class.source = "fold-show"}
shape_estados <- readOGR(dsn ="D:/MGN/MGN 2020/MGN 2020/conjunto_de_datos", 
                             layer = "00ent",
                              encoding = "UTF-8",
                               use_iconv = TRUE)
```

```{r,results=FALSE,class.source = "fold-show"}
shape_municipios <- readOGR(dsn ="D:/MGN/MGN 2020/MGN 2020/conjunto_de_datos", 
                             layer = "00mun",
                              encoding = "UTF-8",
                               use_iconv = TRUE)
```

La funci√≥n `rename()` del paquete `dplyr` permite cambiar el nombre de la columna de la clave geoestad√≠stica a nivel estatal dentro de la base de datos del shape.

```{r,class.source = "fold-show"}
shape_municipios@data <- shape_municipios@data %>%
                          rename("CVE_GEO" = "CVEGEO")
```

### Base de datos

La base de datos del √≠ndice de marginaci√≥n por municipios se encuentra disponible en la p√°gina oficial de [CONAPO](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372) o bien se puede consultar en la p√°gina de [Datos Abiertos](https://datos.gob.mx/) y se presenta en formato `.xlsx` [Consulta](https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad).

Para poder trabajar con la base de datos del √≠ndice de marginaci√≥n a nivel municipal, se elimina la fila que contiene los datos a nivel nacional con la funci√≥n `::filter()` del paquete `dplyr` y por otro lado se cambia el nombre de la columna `CVE_MUN` que hace referencia a la clave geogr√°fica del municipio por `CVE_GEO` para fines pr√°cticos.

```{r, class.source = "fold-show"}
IMM_2020 <- read_xlsx("Bases/IMM_2020.xlsx", sheet = "IMM_2020") %>%
             filter(NOM_ENT != "Nacional") %>%
               mutate(CVE_GEO = CVE_MUN) %>%
                as.data.frame()
```

### SpatialPolygons

Se fusionan los datos del `shape_municipios` con datos estad√≠sticos del √≠ndice de marginaci√≥n a nivel municipal (`IMM_2020`), excluyendo las claves estatales y municipales (`CVE_ENT`, `CVE_MUN`) y asegurando que `GM_2020` se ordene de acuerdo a los grados de marginaci√≥n. El resultado es `layer_municipios`, un objeto que contiene a los municipios junto con sus atributos actualizados, lo que facilita su an√°lisis y visualizaci√≥n en mapas.

#### $$SpatialPolygons \Rightarrow SpatialPolygons + Datos$$

```{r, class.source = "fold-show"}
layer_municipios <- merge(shape_municipios,
                           IMM_2020 %>% dplyr::select(c(-CVE_ENT, -CVE_MUN)) %>%
                                         mutate(GM_2020 = fct_relevel(.$GM_2020,"Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")),
                            by = "CVE_GEO")
```

```{r,fig.height=8, fig.width=10, eval = FALSE, class.source = "fold-hide"}
# Paleta de colores 
require(RColorBrewer)
require(ggspatial)
require(ggpubr)

p <- ggplot() + 
      layer_spatial(layer_municipios, aes(fill = IM_2020), color = "transparent") + 
       layer_spatial(shape_estados, fill = "transparent", color = "black") + 
        theme_bw() + 
         theme(plot.title = element_text(size = 22, hjust = 0.15, family = "montserrat", face = "bold"),
               plot.caption = element_text(size = 11, hjust = 0.2, vjust = 1, family = "montserrat"), 
               legend.key.size = unit(0.5, "cm"),
               legend.text = element_text(size = 12, family = "montserrat"), 
               legend.title = element_text(size = 10, hjust = 0.5, family = "montserrat", face = "bold"),
               legend.position = "right"
               ) + 
          scale_fill_viridis_c(option = "A", begin = 0.3, end = 1) +
           scale_color_manual(values = c("#BDBDBD")) + 
            guides(color = guide_legend(override.aes = list(fill = usecol(pal = pal_petrol, n = 5)))) +
     labs(title = "√çndice de marginaci√≥n a nivel municipal, 2020",
           fill = stringr::str_wrap("Grado de marginaci√≥n", 10), 
            caption = expression(paste("Fuentes: Estimaciones del CONAPO con base en el INEGI, Censo de Poblaci√≥n y Vivienda 2020")))
p
path = "Output/Mapa del IMM2020.pdf"
ggexport(p, filename = path ,width = 10, height = 10, device = "cairo")
```


![](../Output/Mapa del IMM2020.png){width="70%" fig-align="center"}


## Centroides

La funci√≥n `coordinates()` extrae las coordenadas de los centroides de los pol√≠gonos en $(x,y)$ de la base de datos espacial y la almacenamos en la variable `coords`, para su posterior uso en el c√≥digo.

```{r}
# Extrayendo coordenadas desde la base de datos espaciales.
coords = coordinates(layer_municipios)
```

## Tipos de distancias

### Reglas de Vecindad en An√°lisis Espacial

Existen dos reglas principales para definir vecindades espaciales:

1.  **Regla de la Reina (Queen Contiguity, `queen = TRUE`)**\

    -   Considera que dos pol√≠gonos son vecinos si **comparten un v√©rtice o un borde**.\

    -   Es m√°s inclusiva y √∫til para an√°lisis de fen√≥menos continuos.

2.  **Regla de la Torre (Rook Contiguity, `queen = FALSE`)**\

    -   Solo considera vecinos a aquellos pol√≠gonos que **comparten un borde completo** (no solo un v√©rtice).

    -   Es m√°s restrictiva y √∫til cuando se analizan estructuras en cuadr√≠culas.

3.  **Estructura de vecindad espacial basada en los** $ùëò- vecinos$ m√°s cercanos.

    -   Este m√©todo usa la distancia euclidiana en el espacio de coordenadas (latitud y longitud) para determinar los $k$ vecinos m√°s cercanos.

**Comparaci√≥n con otros m√©todos de vecindad**

| M√©todo | Criterio de Vecindad | Tipo de Distancia |
|------------------|-----------------------------|-------------------------|
| `poly2nb(..., queen=TRUE)` | Regla de la Reina (borde o v√©rtice) | Topol√≥gica |
| `poly2nb(..., queen=FALSE)` | Regla de la Torre (solo borde) | Topol√≥gica |
| `knn2nb(knearneigh(coords, k))` | $k$ vecinos m√°s cercanos | Euclidiana |

![](../Output/correlaciones.png)

**C√°lculo del m√°ximo n√∫mero de enlaces posibles**

Si hay $n$ municipios, el n√∫mero m√°ximo de conexiones en una red completamente conectada ser√≠a:

$$
    \frac{n \times (n - 1)}{2}
    $$

donde cada municipio se conecta con todos los dem√°s **sin contar conexiones repetidas** (es decir, sin contar dos veces el mismo par de municipios).

Para $n = 2469$ municipios en la red:

$$
    \frac{2469 \times (2469 - 1)}{2} = \frac{2469 \times 2468}{2} = 3,045,846
    $$

Entonces, en una red **completamente conectada**, habr√≠a **3,045,846 enlaces**.

### Queen contiguity

-   `X_nb_queen` almacena la lista de vecinos generada por `poly2nb()` usando la regla de la reina, con el par√°metro `queen = TRUE`.
-   Es un objeto de clase *nb* (neighborhood), que es una estructura que se utiliza para representar relaciones espaciales en an√°lisis de datos espaciales.

```{r}
# Construyendo lista de vecinos con criterio tipo reina
X_nb_queen = poly2nb(layer_municipios, queen = TRUE)  
summary(X_nb_queen)
```

El resultado describe la estructura de vecindad espacial generada usando la regla de la **reina** para los municipios en el objeto `X_nb_queen`. Vamos a desglosarlo:

-   Se indica que hay 14428 enlaces espaciales no nulos entre los municipios. Un enlace no nulo significa que dos municipios son considerados vecinos seg√∫n la regla de la reina (comparten un borde o v√©rtice). En otras palabras, el n√∫mero total de enlaces (14428) es relativamente peque√±o en comparaci√≥n con el n√∫mero total de posibles enlaces (que ser√≠a mucho mayor si cada municipio estuviera conectado con todos los dem√°s municipios).

-   Aproximadamente el 24% de los enlaces posibles entre los municipios son vecinos. Es decir, solo un peque√±o porcentaje de los posibles pares de municipios est√°n conectados por un enlace de vecindad.

-   Cada municipio, en promedio, est√° conectado con aproximadamente 5.84 municipios vecinos. Es decir, la mayor√≠a de los municipios tienen alrededor de 5-6 vecinos, pero hay 3 municipios muy conectados (hasta 22 vecinos) y otros muy aislados (solo un vecino).

**Comparaci√≥n con el resultado actual**

En la red de vecindad (con la regla de la reina), hay **14,428 enlaces**, lo que representa:

$$
    \frac{14,428}{3,045,846} \times 100 = 0.47% 
    $$

Solo **el 0.47% de los enlaces posibles existen**, lo que indica que la red de vecindad es muy **dispersa** en comparaci√≥n con una red completamente conectada.



### Rook contiguity

`X_nb_rook` es una lista de vecindad espacial basada en la regla del torre (Rook Contiguity) en lugar de la regla de la reina, con el par√°metro `queen = FALSE`.

```{r}
# Construyendo lista de vecinos con criterio  tipo torre
X_nb_rook = poly2nb(layer_municipios, queen = FALSE) 
summary(X_nb_rook)
```

üìå En comparaci√≥n con `X_nb_queen`, esta red de vecindad tiene **menos enlaces**, lo que confirma que hay municipios que solo compart√≠an v√©rtices y que ahora no se consideran vecinos.

-   Se indica que hay 14,200 conexiones entre municipios. Es un poco menor que en `X_nb_queen` (14,428 enlaces), lo que indica que se eliminaron enlaces que solo ocurr√≠an en los v√©rtices. 

-   Aproximadamente el 23.29% de los pares posibles de municipios est√°n conectados. Es decir, solo un peque√±o porcentaje de los posibles pares de municipios est√°n conectados por un enlace de vecindad.

-   Cada municipio, en promedio, est√° conectado con aproximadamente 5.75 vecinos por municipio en promedio. Es decir, la mayor√≠a de los municipios tienen alrededor de 5-6 vecinos, pero hab√≠a 3 municipios con 22 enlaces. Ahora, solo hay 1 municipio con 22 enlaces. 
- Esto indica que algunos municipios perdieron conexiones al aplicar la regla del torre, pero el municipio m√°s conectado sigue teniendo el mismo n√∫mero m√°ximo de enlaces.   

En la red de vecindad (con la regla de la torre), hay **14,200 enlaces**, lo que representa:

$$
    \frac{14,200}{3,045,846} \times 100 = 0.46% 
    $$

Solo **el 0.46% de los enlaces posibles existen**, lo que indica que la red de vecindad es muy **dispersa** en comparaci√≥n con una red completamente conectada y menor al utilizar la regla de la torre.


### k-neighbours contiguity  

`X_kn4` se crea una lista de vecinos basada en la proximidad de coordenadas usando el m√©todo de los $k$ vecinos m√°s cercanos (*k*-nearest neighbors, KNN) con $k = 5$.   

```{r}
# Construyendo lista de vecinos con k-vecinos m√°s cercanos
IDs = row.names(as(layer_municipios, "data.frame")) # Id de las filas
X_kn4 = knn2nb(knearneigh(coords, k = 5), row.names = IDs) 
X_kn4
```

-   Se indica que hay 9876 conexiones entre municipios. - Como se us√≥ \( k = 5 \), cada municipio tiene **exactamente 5 vecinos**, lo que da un total de:  
  \[
    2469 \times 5 = 12 345
    \]
- **A diferencia de `X_nb_queen` o `X_nb_rook`**, donde el n√∫mero de vecinos var√≠a, aqu√≠ **todos tienen exactamente 5 vecinos**.  

-   Aproximadamente el **el 20% de los pares posibles de municipios est√°n conectados**. Es decir, es menor que en `X_nb_queen` (**23.67%**) y `X_nb_rook` (**23.29%**), lo que tiene sentido porque aqu√≠ cada municipio tiene un n√∫mero fijo de vecinos menor que el promedio en los otros m√©todos.

-   Cada municipio, est√° conectado por **5 vecinos por municipio en promedio**. Es decir, esto es **esperado**, ya que en `knn2nb(k = 5)`, cada municipio tiene exactamente 5 vecinos.  

- **En `X_nb_queen` y `X_nb_rook`, el promedio era ~5.8 vecinos** porque depend√≠a de la geometr√≠a de los municipios.

En la red de vecindad (con k - vecinos), hay **12 345 enlaces**, lo que representa:

$$
    \frac{12 345}{3 045 846} \times 100 = 0.40% 
    $$

Solo **el 0.40% de los enlaces posibles existen**, lo que indica que la red de vecindad es muy **dispersa** en comparaci√≥n con una red completamente conectada y menor al utilizar la regla de la reina o torre. 


### **üìä Comparaci√≥n con `X_nb_queen` y `X_nb_rook`**    
  
  
  | M√©todo                           | Vecinos por municipio (promedio) | Total de enlaces | Relaci√≥n sim√©trica |
  |----------------------------------|:------------------------------:|:----------------:|----------------------|
  | Regla de la Reina (`X_nb_queen`) | 5.84                           | 14,428           | ‚úÖ S√≠ | |
  | Regla del Torre (`X_nb_rook`)    | 5.75                           | 14,200           | ‚úÖ S√≠ |
  | KNN con \( k = 4 \) (`X_kn4`)    | 5                              | 9,876            | ‚ùå No |             


```{r, eval = FALSE, class.source = "fold-hide"}
library(ggplot2)
library(sf)
library(spdep)
library(ggspatial)
library(viridis)


#plot(layer_municipios, border = 'lightgrey')
#plot(X_nb_queen, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")

# Se convierten los layer_municipios y centroides a sf (spatial features)
target_crs <- st_crs(layer_municipios) # Extraer CRS original
coords_sf <- st_as_sf(as.data.frame(coords), coords = c("V1", "V2"), crs = target_crs)

# Se obtienen los enlaces de vecinos en formato de l√≠neas
nb_lines <- unlist(
            lapply(1:length(X_nb_queen), function(i) {
              if (length(X_nb_queen[[i]]) > 0) {
                lapply(X_nb_queen[[i]], function(j) {
                  st_linestring(rbind(coords[i, ], coords[j, ]))
                })
              } else {
                NULL
              }
            }), recursive = FALSE
          )

nb_lines_sf <- st_sfc(nb_lines, crs = target_crs)

# Se convierten los enlaces de l√≠neas a un sf object
graph_sf <- st_as_sf(nb_lines_sf, crs = target_crs)

# Crear el gr√°fico
p <- ggplot() +
      layer_spatial(data = shape_estados, fill = "transparent", color = "black") +
       geom_sf(data = graph_sf, color = "#7f7f7f", size = 0.3, alpha = 0.2) +  # L√≠neas de vecinos
        geom_sf(data = coords_sf, color = "#1d6d9c", size = 0.6) +  # Puntos de los municipios
         theme_bw() +
          theme(plot.title = element_text(size = 22, hjust = 0.15, family = "montserrat", face = "bold"),
                plot.subtitle = element_text(size = 20, hjust = 0.15, family = "montserrat", face = "bold"),
                plot.caption = element_text(size = 11, hjust = 0.5, vjust = 1, family = "montserrat"),
                legend.key.size = unit(0.5, "cm"),
                legend.text = element_text(size = 12, family = "montserrat"),
                legend.title = element_text(size = 10, hjust = 0.5, family = "montserrat", face = "bold"),
                legend.position = "right"
                ) +
            labs(title = "Mapa de distancias utilizando la regla de la reina",
                 caption = expression(paste("Fuentes: Elaboraci√≥n propia"))
            )
p

path = paste0(here::here(), "/Output/Mapa de distancias.pdf")
ggexport(p, filename = path ,width = 10, height = 10, device = "cairo")
```

![](../Output/Mapa de distancias.png){width="70%" fig-align="center"}

## Ponderaciones

Construcci√≥n de la matriz de ponderaciones espacial (asignar pesos a las √°reas que est√°n vinculadas). Los pesos espaciales son clave para representar relaciones espaciales, mejorar an√°lisis estad√≠sticos y realizar predicciones m√°s realistas en modelos geoespaciales. 

Para considerar la estructura de vecindad y los efectos espaciales en la estimaci√≥n de los par√°metros se especifica una matriz cuadrada (`W`) denominada matriz de pesos o matriz de ponderaciones, cuyos elementos no negativos dan evidencia de la intensidad de la interdependencia existente entre cada par de unidades geogr√°ficas $i$ y $j$.

`nb2listw` (Pesos espaciales para listas de vecinos): Complementa una lista de vecinos con pesos espaciales para el esquema de codificaci√≥n elegido.

Por defecto, `nb2listw()` asigna **pesos estandarizados por fila (row-standardized weights)**:  
  \[
    w_{ij} = \frac{1}{N_i}
    \]
donde \( N_i \) es el n√∫mero de vecinos del municipio \( i \).  

üìå **Esto significa que la suma de los pesos de cada fila es 1**, lo que ayuda a evitar que municipios con m√°s vecinos dominen el an√°lisis.

---
  
### **üîπ Diferentes Estilos de Pesos**  

Puedes cambiar el estilo de ponderaci√≥n con el argumento `style`:
  
| Estilo (`style`) | Explicaci√≥n |
|------------------|-------------|
| `"B"` (Binario) | 1 si son vecinos, 0 si no lo son |
| `"W"` (Row-standardized, **default**) | Cada peso es \( 1 / N_i \) |
| `"S"` (Suma de filas igual a 1) | Normaliza para evitar sesgos por diferencias en el n√∫mero de vecinos |
| `"U"` (Varianza unitaria) | Pondera para obtener varianza constante en las filas |


Ejemplo en `R`:  

```{r, echo = TRUE, eval = FALSE}
X_nbq_w_bin = nb2listw(X_nb_queen, style = "B")  # Pesos binarios
X_nbq_w_std = nb2listw(X_nb_queen, style = "W")  # Pesos est√°ndar (default)
X_nbq_w_sum = nb2listw(X_nb_queen, style = "S")  # Normalizaci√≥n por suma
```

---
  

### Queen contiguity 

Convierte `X_nb_queen` en un objeto **listw** (lista de pesos espaciales), que es la estructura que `R` usa en an√°lisis espaciales como **Moran‚Äôs I o modelos espaciales**.


```{r}
#   Matriz de pesos normalizados en fila 
# usando QUEEN(W) (Tipo reina):
X_nbq_w = nb2listw(X_nb_queen)
X_nbq_w
```

### Rook contiguity


```{r}
#   Matriz de pesos normalizados en fila 
# usando ROOK(W) (Tipo torre):
X_nbr_w = nb2listw(X_nb_rook)
X_nbr_w
```
### k-neighbours contiguity


```{r}
#   Matriz de pesos normalizados en fila usando k = 5(W):
X_kn4_w = nb2listw(X_kn4)
X_kn4_w
```


Resumen estad√≠stico de la matriz de pesos para cada criterio

```{r}
summary(unlist(X_nbq_w$weights))  # Criterio reina
```

```{r}
summary(unlist(X_nbr_w$weights))  # Criterio torre
```

```{r}
summary(unlist(X_kn4_w$weights))  # Criterio k-vecinos
```

## √çndice de Moran:

Evaluando existencia de autocorrelaci√≥n espacial

El **√çndice de Moran** var√≠a entre -1 y 1:   
  - **\( I > 0 \)** indica correlaci√≥n positiva (valores similares est√°n agrupados).   
- **\( I < 0 \)** indica correlaci√≥n negativa (valores diferentes est√°n cercanos entre s√≠).  
- **\( I \approx 0 \)** sugiere ausencia de autocorrelaci√≥n espacial.   

`moran.test`: (Prueba I de Moran para autocorrelaci√≥n espacial) Utiliza una matriz de ponderaciones espaciales en forma de lista de ponderaciones. La opci√≥n alternativa especifica la hip√≥tesis alternativa, debe ser mayor (predeterminado), menor o como en este caso, bilateral (two.side).

```{r}
# Primero usamos tipo reina:
Ind_Moran_queen = moran.test(layer_municipios$IM_2020, 
                             listw = X_nbq_w, 
                             alternative = "two.side")

# Luego tipo torre
Ind_Moran_rook = moran.test(layer_municipios$IM_2020, 
                            listw = X_nbr_w, 
                            alternative = "two.side")

# Ahora, usamos k = 5:
Ind_Moran_k = moran.test(layer_municipios$IM_2020, 
                         listw = X_kn4_w, 
                         alternative = "two.side") 

Moran_Test <- moran(layer_municipios$IM_2020, listw = X_nbq_w, length(X_nbq_w), Szero(X_nbq_w))
Moran_Test
```



**Conclusi√≥n**: Por lo que los valores se acercan m√°s a 1, significa la existencia de autocorrelaci√≥n espacial positiva.

Recordemos La autocorrelaci√≥n espacial positiva se presenta cuando valores altos [bajos] de la variable de estudio en una localizaci√≥n est√°n asociados con valores altos [bajos] en las regiones vecinas. De manera que la tasa de pobreza en los diferentes puntos se va a presentar de forma similar y esto afirma la posible existencia de cl√∫steres.

### Prueba del estad√≠stico I de Moran

Se calcula un pseudo valor p determinando, la proporci√≥n de los valores I de Moran local generados a partir de permutaciones que muestran m√°s agrupaciones que los datos originales. Si esta proporci√≥n (el pseudo valor p) es peque√±a (menos de 0.05), puede concluir que sus datos muestran agrupaciones estad√≠sticamente significativas.

`moran.mc`: Esta es una prueba de permutaci√≥n para el estad√≠stico I de Moran calculado usando permutaciones aleatorias, para establecer el rango del estad√≠stico observado en relaci√≥n con los nsim valores simulados.

```{r}
moran.mc(layer_municipios$IM_2020, listw = X_nbq_w, nsim=999) # Reina
```

```{r}
moran.mc(layer_municipios$IM_2020, listw = X_nbr_w, nsim=999) # Torre
```

```{r}
moran.mc(layer_municipios$IM_2020, listw = X_kn4_w, nsim=999) # K-vecinos
```

Dado que el p-value para cada m√©todo o criterio es igual a 0.001, y este valor es menor a 0.05, significa que se muestran agrupaciones estad√≠sticamente significativas.

## Prueba C de Geary:

El √≠ndice de Geary (`C`) es un √≠ndice de comparaciones por pares entre las diferentes zonas; por lo general var√≠a entre 0 y 2. - Un valor de $1$ indica ausencia de autocorrelaci√≥n, es decir, que los valores de una zona no est√°n relacionados con los valores de zonas cercanas. - Los valores inferiores a $<1$ indican autocorrelaci√≥n espacial positiva, - Mientras que valores superiores a $>1$ indican autocorrelaci√≥n espacial negativa (Griffith, 1987).

`geary.test`: (Prueba `C` de Geary para autocorrelaci√≥n espacial) Utiliza una matriz de ponderaciones espaciales en forma de lista de ponderaciones. La opci√≥n alternativa especifica la hip√≥tesis alternativa, debe ser mayor (predeterminado), menor o como en este caso, bilateral (two.side).

```{r}
# Primero usamos tipo reina:
C_Geary_reina = geary.test(layer_municipios$IM_2020, listw = X_nbq_w, 
                             alternative = "two.side")

# Luego tipo torre
C_Geary_torre = geary.test(layer_municipios$IM_2020, listw = X_nbr_w, 
                             alternative = "two.side")

# Ahora, usamos k = 4:
C_Geary_k = geary.test(layer_municipios$IM_2020, listw = X_kn4_w, 
                         alternative = "two.side") 
```

Resultados

```{r}
C_Geary_reina
```

```{r}
C_Geary_torre
```

```{r}
C_Geary_k
```

Observamos el C de Geary para:

-   Criterio reina: C =0.3795
-   Criterio torre: C = 0.3772
-   k-vecinos: C = 0.4074

Conclusi√≥n Por lo que los valores son menores que 1, confirma la existencia de autocorrelaci√≥n espacial positiva.

## Prueba del estad√≠stico C de geary

`geary.mc`: Esta es una prueba de permutaci√≥n para el estad√≠stico C de Geary calculado usando permutaciones aleatorias.

```{r}
geary.mc(layer_municipios$IM_2020, listw = X_nbq_w, nsim = 999) # Reina
```

```{r}
geary.mc(layer_municipios$IM_2020, listw = X_nbr_w, nsim = 999) # Torre
```

```{r}
geary.mc(layer_municipios$IM_2020, listw = X_kn4_w, nsim = 999) # K-vecinos
```

Dado que el p-value para cada m√©todo o criterio es igual a 0.001, y este valor es menor a 0.05, significa que se muestran agrupaciones estad√≠sticamente significativas.

## Prueba G(d) de Getis y Ord

globalG.test: La estad√≠stica G global para la autocorrelaci√≥n espacial, que complementa las medidas locales de Gi LISA: localG..

```{r}
# Ahora, usando k = 4:
G_Getis_k = globalG.test(layer_municipios$IM_2020, listw = X_kn4_w, 
                         alternative = "two.side") 
G_Getis_k
```

## Representaci√≥n gr√°fica de la dependencia espacial

n gr√°fico de dispersi√≥n que permite analizar la autocorrelaci√≥n espacial global, es el denominado **Scatterplot de Moran univariante (Anselin, 1993)** .\
Este gr√°fico se construye en un plano cartesiano, en el eje de abscisas se ubican los valores de la variable de estudio estandarizada (x), y en el eje de ordenadas, se ubican los valores del retardo espacial de la variable estandarizada. Enti√©ndase por retardo espacial de una unidad espacial $i$, al valor medio de todos los valores de la variable estandarizada correspondientes a las unidades espaciales vecinas de $i$.

Si la nube de puntos tiende a formarse sobre la diagonal principal del plano cartesiano (cuadrante I y III, en contra de las manecillas de reloj), esto nos indicar√° la presencia de autocorrelaci√≥n espacial positiva.

Si la nube de puntos tiende a ubicarse sobre la diagonal secundaria del plano cartesiano (cuadrante II y IV, en contra de las manecillas de reloj) , ser√° un indicio de existencia de autocorrelaci√≥n espacial negativa.

De lo contrario, si la nube de puntos de distribuye sobre los cuatro cuadrantes, esto nos indicar√° ausencia de autocorrelaci√≥n espacial.

`moran.plot`: (Diagrama de dispersi√≥n de Moran) Una gr√°fica de datos espaciales frente a sus valores espaciales rezagados, aumentada al informar el resumen de las medidas de influencia para la relaci√≥n lineal entre los datos y el rezago.

```{r}
scatterplot_moran = moran.plot(layer_municipios$IM_2020, listw = X_kn4_w, main = "Scatterplot de Moran para la pobreza", labels = unique(IMM_2020$CVE_MUN))
```

Dado que la nube de puntos tiende a formarse sobre la diagonal principal del plano cartesiano (cuadrante I y III), esto indica la presencia de autocorrelaci√≥n espacial positiva.

## Prueba de presencia de autocorrelaci√≥n espacial (local):

Anselin (1995) se refiri√≥ a esto como una estad√≠stica ‚ÄúLISA‚Äù, para Indicador local de autocorrelaci√≥n espacial.

`localmoran`: La estad√≠stica local espacial I de Moran se calcula para cada zona en funci√≥n del objeto de ponderaciones espaciales.

`lag.listw`: Usando una representaci√≥n dispersa de listw de una matriz de ponderaciones espaciales, calcula el vector de retardo.

```{r}
criterio <- X_nbq_w
LISA <- function(criterio) {
  
          P = localmoran(layer_municipios$IM_2020, listw = criterio)
          cX = layer_municipios$IM_2020 - mean(layer_municipios$IM_2020) # IM - Media(IM)
          lagDV = lag.listw(X_nbq_w, layer_municipios$IM_2020) # Calcula el retardo (promedios)
          clagDV = lagDV - mean(lagDV) # Retardo - Media(Retardo)
          p = P[,5] # Toma la columna: Pr(z > 0) de P
        
          # Se inicializa vector numerico de longitud filas de P (666)
          quadrant = vector(mode="numeric",length=nrow(P))+5
          quadrant[cX>0 & clagDV>0 & p<= 0.05] = 1 # Alto-Alto
          quadrant[cX<0 & clagDV<0 & p<= 0.05] = 2 # Bajo-Bajo
          quadrant[cX<0 & clagDV>0 & p<= 0.05] = 3 # Bajo-Alto
          quadrant[cX>0 & clagDV<0 & p<= 0.05] = 4 # Alto-Bajo
        
          # Grafico  
          brks = c(1,2,3,4,5)
          colors = c("red", "blue", "light blue", "pink", "white")
          plot(layer_municipios, border ="lightgray", col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
          legend("bottomright", legend = c("High-High", "Low-Low", "Low-High", "High-Low", "Insignificant"), fill = colors, bty="n", cex=0.7, y.intersp=1, x.intersp=1)
          box()
          title("LISA Cluster Map")
}
```

```{r}
LISA(criterio = X_nbq_w)
```

```{r, eval = FALSE}
tabla <- read.delim("C:/Users/dvill/Downloads/2022_12_3_00/2022_12_3_00.txt", sep = "\t", fill = TRUE , header = TRUE, quote = "\"")

require(Rcmdr)


#library(data.table)
#setDT(df)[, observacion_izquierda := shift(observacion, n = 1, fill = NA, type = "lead")]
```

## Librer√≠as

**Librer√≠as que se usaron en el trabajo**

```{r, echo = FALSE}
names(sessionInfo()$otherPkgs)
```

## Referencias

Anselin, L. (1995). Local Indicators of Spatial Association‚ÄîLISA. Geographical Analysis, 27(2), 93‚Äì115.

Datos Abiertos de M√©xico - √çndice de marginaci√≥n (carencias poblacionales) por localidad, municipio y entidad. (2021). Retrieved February 13, 2022, from <https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad>

Bivand, R. S., Pebesma, E., & G√≥mez-Rubio, V. (2013). Applied Spatial Data Analysis with R (2nd ed.). Springer.

RPubs - Spatial Clustering of Univariate Geographically Referenced Attribute. (2020). Retrieved January 30, 2025, from <https://rpubs.com/erikaaldisa/spatialclustering>
