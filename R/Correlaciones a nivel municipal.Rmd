---
title: "Análisis estadístico espacial"
subtitle: "Utilizando el índice de marginación a nivel municipal"
author: "Diana Villasana Ocampo"
knit: (function(inputFile, encoding) {
       rmarkdown::render(inputFile, encoding = encoding, output_dir = "../Output/")
  })
output:
   html_document:
      code_folding: hide
      highlight: tango
      theme: flatly
      toc: true
      toc_depth: 3
      toc_float:
        collapsed: yes
---

```{=html}
<style type="text/css">
body {
text-align: justify;
font-style: normal;
font-family: "Montserrat";
font-size: 12px
}
h1.title {
  font-size: 40px;
  color: #000D3B;
}
h1 {
  color: #B6854D;
}
h2 {
  color: #172984;
}
h3 {
  color: #172984;
}
</style>
```

```{=html}
<style>
.nav>li>a {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #1C3BA4
}
.nav-pills>li.active>a, .nav-pills>li.active>a:hover, .nav-pills>li>a:focus {
    color: #ffffff;
    background-color: #09C2BC
}
</style>
```

```{=html}
<style>
.tile1-text {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #0A6A87;
    list-style: none;
}
.top1-tiles a:nth-of-type(1):hover, .top-tiles1 a:nth-of-type(1):focus{
    color: #ffffff;
    background: #0A6A87
}
</style>
```

```{=html}
<style>
.tile2-text {
    position: relative;
    display: block;
    padding: 10px 15px;
    color: #0A6CC8;
    list-style: none;
}
.top2-tiles a:nth-of-type(1):hover, .top2-tiles a:nth-of-type(1):focus{
    color: #ffffff;
    background: #0A6CC8
}
</style>
```

```{=html}
<style>
.math {
  font-size: 15px;
  color: #B6854D;
}
</style>
```


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE, 
                      cache.lazy = FALSE, class.source = "fold-show")
knitr::opts_knit$set(root.dir = here::here())
setwd(here::here())
```

```{r,echo=FALSE, eval=FALSE}
rm(list = ls())
```

```{r, echo = FALSE, results=FALSE}
# Paquetes que se usaron en el documento 
require(dplyr)          #A Grammar of Data Manipulation 
require(forcats)        #Tools for Working with Categorical Variables (Factors)
require(ggplot2)        # Generar gráficos ggplot y la geometría de un mapa
require(ggthemes)       # Extra Themes, scale and Geoms for ggplot2
require(ggmap)          #Spatial Visualization with ggplot2 
require(ggpubr)         # Based Publication Ready Plots with ggplot2
require(ggimage)        # Plot images
require(grDevices)      # Read vector files .svg
require(knitr)
require(kableExtra)
require(lubridate)
library(maptools)
require(openxlsx)
require(readxl)
require(RColorBrewer)   #ColorBrewer Palettes 
require(rgdal)          #Para importar shapefiles. 
require(sp)             # Classes and Methos for Spatial Data
library(spdep)    # Índice de Moran 
require(spdplyr)        #Data manipulation verbs for the sptial classes
require(tidyverse) 
require(tmap)
require(tmaptools)
require(tibble)
require(unikn)          # Paleta de colores
require(viridisLite)    # Paleta de colores
```

```{r, echo = FALSE, results=FALSE}
# Se descargan las fuentes de la google fonts
require(showtext)
# activar showtext
showtext_auto()
font_add_google("Montserrat", "montserrat")
```

## Objetivo

El análisis espacial es un conjunto de técnicas y herramientas utilizadas para estudiar y comprender patrones, relaciones y procesos geográficos en un contexto espacial. Es decir, se enfoca en cómo los datos se distribuyen en el espacio y cómo se relacionan entre sí, en el cúal se utilizan técnicas como el mapeo, estadística espacial, sistemas de información geográfica (`SIG`)` y la visualización para examinar los datos geográficos y descubrir patrones y relaciones en ellos.

Estas técnicas permiten la detección de patrones y tendencias, la evaluación de la accesibilidad y la conectividad, la modelización de procesos geográficos y la planificación y toma de decisiones basadas en la información geográfica. La cuales sirven como ayuda para campos, como la geografía, planificación urbana, epidemiología, gestión de recursos naturales, criminología y arqueología, entre otros.

## Correlaciones espaciales

Las correlaciones espaciales permiten analizar la relación entre variables geográficas considerando su distribución en el espacio. A diferencia de las correlaciones tradicionales, que suponen independencia entre observaciones, las correlaciones espaciales reconocen que valores cercanos tienden a estar más relacionados que aquellos más alejados, fenómeno conocido como autocorrelación espacial. Este tipo de análisis es fundamental en estudios de patrones geográficos, como la distribución de la pobreza, el acceso a servicios o la dinámica migratoria, y se mide comúnmente mediante indicadores como el `índice de Moran` o la `estadística de Geary`. Su aplicación ayuda a identificar clusters espaciales, entender dinámicas territoriales y mejorar la toma de decisiones en políticas públicas y planificación urbana.

El cálculo de la correlación espacial se basa en la relación entre los valores de una variable y su distribución geográfica. Los métodos más utilizados son el **Índice de Moran** y la **estadística de Geary**, que cuantifican la autocorrelación espacial en diferentes escalas.

### 1. Índice de Moran ($I$)

El **Índice de Moran** mide la autocorrelación espacial global, es decir, qué tan similar es una variable en función de su ubicación. Se calcula como:

$$
I = \frac{N}{W} \times \frac{\sum_{i} \sum_{j} w_{ij} (x_i - \bar{x})(x_j - \bar{x})}{\sum_{i} (x_i - \bar{x})^2}, \quad D : \left\{x \in [-1, 1] \right\}
$$

donde:

\- $N$ es el número total de observaciones,

\- $x_i$ y $x_j$ son los valores de la variable en las ubicaciones $i$ y $j$,

\- $\bar{x}$ es la media de la variable,

\- $w_{ij}$ es la matriz de pesos espaciales que define la relación entre ubicaciones (por ejemplo, vecindad contigua o distancia),

\- $W$ es la suma de todos los pesos espaciales.

El **Índice de Moran** varía entre $-1$ y $1$:

\- $I > 0$ indica correlación positiva (valores similares están agrupados).

\- $I < 0$ indica correlación negativa (valores diferentes están cercanos entre sí).

\- $I \approx 0$ sugiere ausencia de autocorrelación espacial.

### 2. Estadística de Geary ($C$)

La estadística de Geary también mide autocorrelación espacial, pero es más sensible a las diferencias locales. Se calcula como:

$$
C = \frac{(N-1)}{2W} \times \frac{\sum_{i} \sum_{j} w_{ij} (x_i - x_j)^2}{\sum_{i} (x_i - \bar{x})^2}
$$

donde los términos son los mismos que en el Índice de Moran.

El **valor de** $C$ varía entre $0$ y $2$:

\- $C \approx 1$ indica independencia espacial (ausencia de correlación).

\- $C < 1$ sugiere autocorrelación espacial positiva (valores similares están cerca).

\- $C > 1$ indica autocorrelación espacial negativa (valores diferentes están cercanos entre sí).

### 3. Estadística de Getis-Ord ($G_i^*$)

La estadística de **Getis-Ord** $G_i^*$ es una medida local de autocorrelación espacial que identifica clusters de valores altos o bajos en una distribución geográfica. Se usa principalmente para detectar **zonas calientes ("hot spots") y zonas frías ("cold spots")**, lo que la hace útil en análisis de crimen, salud pública, economía y planificación urbana.

#### Fórmula de Getis-Ord $G_i^*$:

$$
G_i^* = \frac{\sum_{j} w_{ij} x_j}{\sum_{j} x_j}
$$

donde:\
- $x_j$ es el valor de la variable en la ubicación $j$,

\- $w_{ij}$ es el peso espacial entre las ubicaciones $i$ y $j$,

\- $\sum_{j} x_j$ es la suma total de la variable en todas las ubicaciones.

Para interpretar los resultados, se suele estandarizar $G_i^*$ en forma de una puntuación $Z$:

$$
Z(G_i^*) = \frac{\sum_j w_{ij} x_j - \bar{X} W_i}{S}
$$

donde:

\- $\bar{X}$ es la media de la variable en toda el área de estudio,

\- $W_i$ es la suma de los pesos espaciales para la ubicación $i$,

\- $S$ es la desviación estándar de la variable en la región.

#### Interpretación de $G_i^*$:

-   $Z(G_i^*) > 1.96$ (p \< 0.05) → Indica un **hot spot** (zona con valores altos agrupados significativamente).\
-   $Z(G_i^*) < -1.96$ (p \< 0.05) → Indica un **cold spot** (zona con valores bajos agrupados significativamente).\
-   $Z(G_i^*) \approx 0$ → No hay patrones espaciales significativos.

#### **Diferencia con el Índice de Moran:**

-   **Moran’s I** mide la autocorrelación espacial **global**, indicando si los valores están agrupados en toda la región.\
-   **Getis-Ord** $G_i^*$ detecta **clusters locales**, permitiendo identificar áreas específicas con concentraciones altas o bajas.

#### **Aplicaciones:**

-   En criminología, para encontrar **zonas de alta delincuencia**.\
-   En epidemiología, para detectar **zonas con alta incidencia de enfermedades**.\
-   En economía, para analizar **concentraciones de riqueza o pobreza**.\
-   En urbanismo, para identificar **áreas de crecimiento acelerado o deterioro urbano**.

Esta estadística es ampliamente utilizada en **Sistemas de Información Geográfica (SIG)** y está implementada en software como **ArcGIS, GeoDa y R** (paquetes `spdep` y `sf`).

## Marco Geoestadístico Nacional (MGN) 2020

El **Marco Geoestadístico Nacional (MGN) 2020** del **Instituto Nacional de Estadística y Geografía (INEGI)** es un sistema de referencia geográfica que define la división territorial de México para la recopilación, análisis y presentación de información estadística. Se utiliza principalmente en censos y encuestas para garantizar la compatibilidad de datos espaciales a nivel nacional.

#### **Características principales del MGN 2020:**

1.  **Unidades geográficas:**
    -   **Áreas Geoestadísticas Estatales (AGEE):** corresponden a los estados.\
    -   **Áreas Geoestadísticas Municipales (AGEM):** coinciden con los municipios.\
    -   **Áreas Geoestadísticas Básicas (AGEB):** subdivisiones de los municipios, utilizadas en zonas urbanas y rurales.\
    -   **Manzanas geoestadísticas:** delimitaciones dentro de las AGEB urbanas.
2.  **Proyección y sistema de coordenadas:**
    -   Utiliza el **Sistema de Referencia Geodésico ITRF2008** en coordenadas geográficas con el **datum WGS84**.\
    -   Se presenta en formato vectorial compatible con SIG (Sistemas de Información Geográfica), en formatos como **Shapefile (SHP)** y **GeoJSON**.

#### Shapefile

La función `readOGR` del paquete `rgdal`, extrae automáticamente la información utilizada por otros paquetes `SIG` de código abierto como QGIS y permite a R manejar una gama más amplia de formatos de datos espaciales. Esta función lee datos `OGR` y datos vectoriales, pero solamente permite manejar capas con características geométricas (no mezcla puntos, líneas o polígonos en una sola capa) y a su vez establecerá un sistema de referencia espacial si la capa tiene dichos metadatos.\
Para leer un archivo `shapefile`, se establecen los siguientes argumentos, como `dsn`, en donde se indica el directorio que contiene los shapes y `layer` que es el nombre explícito de la capa a trabajar y dichas capas deben de ir sin la extensión `.shp`.

A continuación, se lee el archivo .shp que contiene de manera integrada la división de el área geoestadística municipal `agem`.

```{r,results=FALSE,class.source = "fold-show"}
shape_estados <- readOGR(dsn ="D:/MGN/MGN 2020/MGN 2020/conjunto_de_datos", 
                             layer = "00ent",
                              encoding = "UTF-8",
                               use_iconv = TRUE)
```

```{r,results=FALSE,class.source = "fold-show"}
shape_municipios <- readOGR(dsn ="D:/MGN/MGN 2020/MGN 2020/conjunto_de_datos", 
                             layer = "00mun",
                              encoding = "UTF-8",
                               use_iconv = TRUE)
```

La función `rename()` del paquete `dplyr` permite cambiar el nombre de la columna de la clave geoestadística a nivel estatal dentro de la base de datos del shape.

```{r,class.source = "fold-show"}
shape_municipios@data <- shape_municipios@data %>%
                          rename("CVE_GEO" = "CVEGEO")
```

### Base de datos

La base de datos del índice de marginación por municipios se encuentra disponible en la página oficial de [CONAPO](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372) o bien se puede consultar en la página de [Datos Abiertos](https://datos.gob.mx/) y se presenta en formato `.xlsx` [Consulta](https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad).

Para poder trabajar con la base de datos del índice de marginación a nivel municipal, se elimina la fila que contiene los datos a nivel nacional con la función `::filter()` del paquete `dplyr` y por otro lado se cambia el nombre de la columna `CVE_MUN` que hace referencia a la clave geográfica del municipio por `CVE_GEO` para fines prácticos.

```{r, class.source = "fold-show"}
IMM_2020 <- read_xlsx("Bases/IMM_2020.xlsx", sheet = "IMM_2020") %>%
             filter(NOM_ENT != "Nacional") %>%
               mutate(CVE_GEO = CVE_MUN) %>%
                as.data.frame()
```

### SpatialPolygons

Se fusionan los datos del `shape_municipios` con datos estadísticos del índice de marginación a nivel municipal (`IMM_2020`), excluyendo las claves estatales y municipales (`CVE_ENT`, `CVE_MUN`) y asegurando que `GM_2020` se ordene de acuerdo a los grados de marginación. El resultado es `layer_municipios`, un objeto que contiene a los municipios junto con sus atributos actualizados, lo que facilita su análisis y visualización en mapas.

#### $$SpatialPolygons \Rightarrow SpatialPolygons + Datos$$

```{r, class.source = "fold-show"}
layer_municipios <- merge(shape_municipios,
                           IMM_2020 %>% dplyr::select(c(-CVE_ENT, -CVE_MUN)) %>%
                                         mutate(GM_2020 = fct_relevel(.$GM_2020,"Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")),
                            by = "CVE_GEO")
```

```{r,fig.height=8, fig.width=10, eval = FALSE, class.source = "fold-hide"}
# Paleta de colores 
require(RColorBrewer)
require(ggspatial)
require(ggpubr)

p <- ggplot() + 
      layer_spatial(layer_municipios, aes(fill = IM_2020), color = "transparent") + 
       layer_spatial(shape_estados, fill = "transparent", color = "black") + 
        theme_bw() + 
         theme(plot.title = element_text(size = 22, hjust = 0.15, family = "montserrat", face = "bold"),
               plot.caption = element_text(size = 11, hjust = 0.2, vjust = 1, family = "montserrat"), 
               legend.key.size = unit(0.5, "cm"),
               legend.text = element_text(size = 12, family = "montserrat"), 
               legend.title = element_text(size = 10, hjust = 0.5, family = "montserrat", face = "bold"),
               legend.position = "right"
               ) + 
          scale_fill_viridis_c(option = "A", begin = 0.3, end = 1) +
           scale_color_manual(values = c("#BDBDBD")) + 
            guides(color = guide_legend(override.aes = list(fill = usecol(pal = pal_petrol, n = 5)))) +
     labs(title = "Índice de marginación a nivel municipal, 2020",
           fill = stringr::str_wrap("Grado de marginación", 10), 
            caption = expression(paste("Fuentes: Estimaciones del CONAPO con base en el INEGI, Censo de Población y Vivienda 2020")))
p
path = "Output/Mapa del IMM2020.pdf"
ggexport(p, filename = path ,width = 10, height = 10, device = "cairo")
```


![](../Output/Mapa del IMM2020.png){width="70%" fig-align="center"}


## Centroides

La función `coordinates()` extrae las coordenadas de los centroides de los polígonos en $(x,y)$ de la base de datos espacial y la almacenamos en la variable `coords`, para su posterior uso en el código.

```{r}
# Extrayendo coordenadas desde la base de datos espaciales.
coords = coordinates(layer_municipios)
```

## Tipos de distancias

### Reglas de Vecindad en Análisis Espacial

Existen dos reglas principales para definir vecindades espaciales:

1.  **Regla de la Reina (Queen Contiguity, `queen = TRUE`)**\

    -   Considera que dos polígonos son vecinos si **comparten un vértice o un borde**.\

    -   Es más inclusiva y útil para análisis de fenómenos continuos.

2.  **Regla de la Torre (Rook Contiguity, `queen = FALSE`)**\

    -   Solo considera vecinos a aquellos polígonos que **comparten un borde completo** (no solo un vértice).

    -   Es más restrictiva y útil cuando se analizan estructuras en cuadrículas.

3.  **Estructura de vecindad espacial basada en los** $𝑘- vecinos$ más cercanos.

    -   Este método usa la distancia euclidiana en el espacio de coordenadas (latitud y longitud) para determinar los $k$ vecinos más cercanos.

**Comparación con otros métodos de vecindad**

| Método | Criterio de Vecindad | Tipo de Distancia |
|------------------|-----------------------------|-------------------------|
| `poly2nb(..., queen=TRUE)` | Regla de la Reina (borde o vértice) | Topológica |
| `poly2nb(..., queen=FALSE)` | Regla de la Torre (solo borde) | Topológica |
| `knn2nb(knearneigh(coords, k))` | $k$ vecinos más cercanos | Euclidiana |

![](../Output/correlaciones.png)

**Cálculo del máximo número de enlaces posibles**

Si hay $n$ municipios, el número máximo de conexiones en una red completamente conectada sería:

$$
    \frac{n \times (n - 1)}{2}
    $$

donde cada municipio se conecta con todos los demás **sin contar conexiones repetidas** (es decir, sin contar dos veces el mismo par de municipios).

Para $n = 2469$ municipios en la red:

$$
    \frac{2469 \times (2469 - 1)}{2} = \frac{2469 \times 2468}{2} = 3,045,846
    $$

Entonces, en una red **completamente conectada**, habría **3,045,846 enlaces**.

### Queen contiguity

-   `X_nb_queen` almacena la lista de vecinos generada por `poly2nb()` usando la regla de la reina, con el parámetro `queen = TRUE`.
-   Es un objeto de clase *nb* (neighborhood), que es una estructura que se utiliza para representar relaciones espaciales en análisis de datos espaciales.

```{r}
# Construyendo lista de vecinos con criterio tipo reina
X_nb_queen = poly2nb(layer_municipios, queen = TRUE)  
summary(X_nb_queen)
```

El resultado describe la estructura de vecindad espacial generada usando la regla de la **reina** para los municipios en el objeto `X_nb_queen`. Vamos a desglosarlo:

-   Se indica que hay 14428 enlaces espaciales no nulos entre los municipios. Un enlace no nulo significa que dos municipios son considerados vecinos según la regla de la reina (comparten un borde o vértice). En otras palabras, el número total de enlaces (14428) es relativamente pequeño en comparación con el número total de posibles enlaces (que sería mucho mayor si cada municipio estuviera conectado con todos los demás municipios).

-   Aproximadamente el 24% de los enlaces posibles entre los municipios son vecinos. Es decir, solo un pequeño porcentaje de los posibles pares de municipios están conectados por un enlace de vecindad.

-   Cada municipio, en promedio, está conectado con aproximadamente 5.84 municipios vecinos. Es decir, la mayoría de los municipios tienen alrededor de 5-6 vecinos, pero hay 3 municipios muy conectados (hasta 22 vecinos) y otros muy aislados (solo un vecino).

**Comparación con el resultado actual**

En la red de vecindad (con la regla de la reina), hay **14,428 enlaces**, lo que representa:

$$
    \frac{14,428}{3,045,846} \times 100 = 0.47% 
    $$

Solo **el 0.47% de los enlaces posibles existen**, lo que indica que la red de vecindad es muy **dispersa** en comparación con una red completamente conectada.



### Rook contiguity

`X_nb_rook` es una lista de vecindad espacial basada en la regla del torre (Rook Contiguity) en lugar de la regla de la reina, con el parámetro `queen = FALSE`.

```{r}
# Construyendo lista de vecinos con criterio  tipo torre
X_nb_rook = poly2nb(layer_municipios, queen = FALSE) 
summary(X_nb_rook)
```

📌 En comparación con `X_nb_queen`, esta red de vecindad tiene **menos enlaces**, lo que confirma que hay municipios que solo compartían vértices y que ahora no se consideran vecinos.

-   Se indica que hay 14,200 conexiones entre municipios. Es un poco menor que en `X_nb_queen` (14,428 enlaces), lo que indica que se eliminaron enlaces que solo ocurrían en los vértices. 

-   Aproximadamente el 23.29% de los pares posibles de municipios están conectados. Es decir, solo un pequeño porcentaje de los posibles pares de municipios están conectados por un enlace de vecindad.

-   Cada municipio, en promedio, está conectado con aproximadamente 5.75 vecinos por municipio en promedio. Es decir, la mayoría de los municipios tienen alrededor de 5-6 vecinos, pero había 3 municipios con 22 enlaces. Ahora, solo hay 1 municipio con 22 enlaces. 
- Esto indica que algunos municipios perdieron conexiones al aplicar la regla del torre, pero el municipio más conectado sigue teniendo el mismo número máximo de enlaces.   

En la red de vecindad (con la regla de la torre), hay **14,200 enlaces**, lo que representa:

$$
    \frac{14,200}{3,045,846} \times 100 = 0.46% 
    $$

Solo **el 0.46% de los enlaces posibles existen**, lo que indica que la red de vecindad es muy **dispersa** en comparación con una red completamente conectada y menor al utilizar la regla de la torre.


### k-neighbours contiguity  

`X_kn4` se crea una lista de vecinos basada en la proximidad de coordenadas usando el método de los $k$ vecinos más cercanos (*k*-nearest neighbors, KNN) con $k = 5$.   

```{r}
# Construyendo lista de vecinos con k-vecinos más cercanos
IDs = row.names(as(layer_municipios, "data.frame")) # Id de las filas
X_kn4 = knn2nb(knearneigh(coords, k = 5), row.names = IDs) 
X_kn4
```

-   Se indica que hay 9876 conexiones entre municipios. - Como se usó \( k = 5 \), cada municipio tiene **exactamente 5 vecinos**, lo que da un total de:  
  \[
    2469 \times 5 = 12 345
    \]
- **A diferencia de `X_nb_queen` o `X_nb_rook`**, donde el número de vecinos varía, aquí **todos tienen exactamente 5 vecinos**.  

-   Aproximadamente el **el 20% de los pares posibles de municipios están conectados**. Es decir, es menor que en `X_nb_queen` (**23.67%**) y `X_nb_rook` (**23.29%**), lo que tiene sentido porque aquí cada municipio tiene un número fijo de vecinos menor que el promedio en los otros métodos.

-   Cada municipio, está conectado por **5 vecinos por municipio en promedio**. Es decir, esto es **esperado**, ya que en `knn2nb(k = 5)`, cada municipio tiene exactamente 5 vecinos.  

- **En `X_nb_queen` y `X_nb_rook`, el promedio era ~5.8 vecinos** porque dependía de la geometría de los municipios.

En la red de vecindad (con k - vecinos), hay **12 345 enlaces**, lo que representa:

$$
    \frac{12 345}{3 045 846} \times 100 = 0.40% 
    $$

Solo **el 0.40% de los enlaces posibles existen**, lo que indica que la red de vecindad es muy **dispersa** en comparación con una red completamente conectada y menor al utilizar la regla de la reina o torre. 


### **📊 Comparación con `X_nb_queen` y `X_nb_rook`**    
  
  
  | Método                           | Vecinos por municipio (promedio) | Total de enlaces | Relación simétrica |
  |----------------------------------|:------------------------------:|:----------------:|----------------------|
  | Regla de la Reina (`X_nb_queen`) | 5.84                           | 14,428           | ✅ Sí | |
  | Regla del Torre (`X_nb_rook`)    | 5.75                           | 14,200           | ✅ Sí |
  | KNN con \( k = 4 \) (`X_kn4`)    | 5                              | 9,876            | ❌ No |             


```{r, eval = FALSE, class.source = "fold-hide"}
library(ggplot2)
library(sf)
library(spdep)
library(ggspatial)
library(viridis)


#plot(layer_municipios, border = 'lightgrey')
#plot(X_nb_queen, coords, pch = 19, cex = 0.6, add = TRUE, col = "red")

# Se convierten los layer_municipios y centroides a sf (spatial features)
target_crs <- st_crs(layer_municipios) # Extraer CRS original
coords_sf <- st_as_sf(as.data.frame(coords), coords = c("V1", "V2"), crs = target_crs)

# Se obtienen los enlaces de vecinos en formato de líneas
nb_lines <- unlist(
            lapply(1:length(X_nb_queen), function(i) {
              if (length(X_nb_queen[[i]]) > 0) {
                lapply(X_nb_queen[[i]], function(j) {
                  st_linestring(rbind(coords[i, ], coords[j, ]))
                })
              } else {
                NULL
              }
            }), recursive = FALSE
          )

nb_lines_sf <- st_sfc(nb_lines, crs = target_crs)

# Se convierten los enlaces de líneas a un sf object
graph_sf <- st_as_sf(nb_lines_sf, crs = target_crs)

# Crear el gráfico
p <- ggplot() +
      layer_spatial(data = shape_estados, fill = "transparent", color = "black") +
       geom_sf(data = graph_sf, color = "#7f7f7f", size = 0.3, alpha = 0.2) +  # Líneas de vecinos
        geom_sf(data = coords_sf, color = "#1d6d9c", size = 0.6) +  # Puntos de los municipios
         theme_bw() +
          theme(plot.title = element_text(size = 22, hjust = 0.15, family = "montserrat", face = "bold"),
                plot.subtitle = element_text(size = 20, hjust = 0.15, family = "montserrat", face = "bold"),
                plot.caption = element_text(size = 11, hjust = 0.5, vjust = 1, family = "montserrat"),
                legend.key.size = unit(0.5, "cm"),
                legend.text = element_text(size = 12, family = "montserrat"),
                legend.title = element_text(size = 10, hjust = 0.5, family = "montserrat", face = "bold"),
                legend.position = "right"
                ) +
            labs(title = "Mapa de distancias utilizando la regla de la reina",
                 caption = expression(paste("Fuentes: Elaboración propia"))
            )
p

path = paste0(here::here(), "/Output/Mapa de distancias.pdf")
ggexport(p, filename = path ,width = 10, height = 10, device = "cairo")
```

![](../Output/Mapa de distancias.png){width="70%" fig-align="center"}

## Ponderaciones

Construcción de la matriz de ponderaciones espacial (asignar pesos a las áreas que están vinculadas). Los pesos espaciales son clave para representar relaciones espaciales, mejorar análisis estadísticos y realizar predicciones más realistas en modelos geoespaciales. 

Para considerar la estructura de vecindad y los efectos espaciales en la estimación de los parámetros se especifica una matriz cuadrada (`W`) denominada matriz de pesos o matriz de ponderaciones, cuyos elementos no negativos dan evidencia de la intensidad de la interdependencia existente entre cada par de unidades geográficas $i$ y $j$.

`nb2listw` (Pesos espaciales para listas de vecinos): Complementa una lista de vecinos con pesos espaciales para el esquema de codificación elegido.

Por defecto, `nb2listw()` asigna **pesos estandarizados por fila (row-standardized weights)**:  
  \[
    w_{ij} = \frac{1}{N_i}
    \]
donde \( N_i \) es el número de vecinos del municipio \( i \).  

📌 **Esto significa que la suma de los pesos de cada fila es 1**, lo que ayuda a evitar que municipios con más vecinos dominen el análisis.

---
  
### **🔹 Diferentes Estilos de Pesos**  

Puedes cambiar el estilo de ponderación con el argumento `style`:
  
| Estilo (`style`) | Explicación |
|------------------|-------------|
| `"B"` (Binario) | 1 si son vecinos, 0 si no lo son |
| `"W"` (Row-standardized, **default**) | Cada peso es \( 1 / N_i \) |
| `"S"` (Suma de filas igual a 1) | Normaliza para evitar sesgos por diferencias en el número de vecinos |
| `"U"` (Varianza unitaria) | Pondera para obtener varianza constante en las filas |


Ejemplo en `R`:  

```{r, echo = TRUE, eval = FALSE}
X_nbq_w_bin = nb2listw(X_nb_queen, style = "B")  # Pesos binarios
X_nbq_w_std = nb2listw(X_nb_queen, style = "W")  # Pesos estándar (default)
X_nbq_w_sum = nb2listw(X_nb_queen, style = "S")  # Normalización por suma
```

---
  

### Queen contiguity 

Convierte `X_nb_queen` en un objeto **listw** (lista de pesos espaciales), que es la estructura que `R` usa en análisis espaciales como **Moran’s I o modelos espaciales**.


```{r}
#   Matriz de pesos normalizados en fila 
# usando QUEEN(W) (Tipo reina):
X_nbq_w = nb2listw(X_nb_queen)
X_nbq_w
```

### Rook contiguity


```{r}
#   Matriz de pesos normalizados en fila 
# usando ROOK(W) (Tipo torre):
X_nbr_w = nb2listw(X_nb_rook)
X_nbr_w
```
### k-neighbours contiguity


```{r}
#   Matriz de pesos normalizados en fila usando k = 5(W):
X_kn4_w = nb2listw(X_kn4)
X_kn4_w
```


Resumen estadístico de la matriz de pesos para cada criterio

```{r}
summary(unlist(X_nbq_w$weights))  # Criterio reina
```

```{r}
summary(unlist(X_nbr_w$weights))  # Criterio torre
```

```{r}
summary(unlist(X_kn4_w$weights))  # Criterio k-vecinos
```

## Índice de Moran:

Evaluando existencia de autocorrelación espacial

El **Índice de Moran** varía entre -1 y 1:   
  - **\( I > 0 \)** indica correlación positiva (valores similares están agrupados).   
- **\( I < 0 \)** indica correlación negativa (valores diferentes están cercanos entre sí).  
- **\( I \approx 0 \)** sugiere ausencia de autocorrelación espacial.   

`moran.test`: (Prueba I de Moran para autocorrelación espacial) Utiliza una matriz de ponderaciones espaciales en forma de lista de ponderaciones. La opción alternativa especifica la hipótesis alternativa, debe ser mayor (predeterminado), menor o como en este caso, bilateral (two.side).

```{r}
# Primero usamos tipo reina:
Ind_Moran_queen = moran.test(layer_municipios$IM_2020, 
                             listw = X_nbq_w, 
                             alternative = "two.side")

# Luego tipo torre
Ind_Moran_rook = moran.test(layer_municipios$IM_2020, 
                            listw = X_nbr_w, 
                            alternative = "two.side")

# Ahora, usamos k = 5:
Ind_Moran_k = moran.test(layer_municipios$IM_2020, 
                         listw = X_kn4_w, 
                         alternative = "two.side") 

Moran_Test <- moran(layer_municipios$IM_2020, listw = X_nbq_w, length(X_nbq_w), Szero(X_nbq_w))
Moran_Test
```



**Conclusión**: Por lo que los valores se acercan más a 1, significa la existencia de autocorrelación espacial positiva.

Recordemos La autocorrelación espacial positiva se presenta cuando valores altos [bajos] de la variable de estudio en una localización están asociados con valores altos [bajos] en las regiones vecinas. De manera que la tasa de pobreza en los diferentes puntos se va a presentar de forma similar y esto afirma la posible existencia de clústeres.

### Prueba del estadístico I de Moran

Se calcula un pseudo valor p determinando, la proporción de los valores I de Moran local generados a partir de permutaciones que muestran más agrupaciones que los datos originales. Si esta proporción (el pseudo valor p) es pequeña (menos de 0.05), puede concluir que sus datos muestran agrupaciones estadísticamente significativas.

`moran.mc`: Esta es una prueba de permutación para el estadístico I de Moran calculado usando permutaciones aleatorias, para establecer el rango del estadístico observado en relación con los nsim valores simulados.

```{r}
moran.mc(layer_municipios$IM_2020, listw = X_nbq_w, nsim=999) # Reina
```

```{r}
moran.mc(layer_municipios$IM_2020, listw = X_nbr_w, nsim=999) # Torre
```

```{r}
moran.mc(layer_municipios$IM_2020, listw = X_kn4_w, nsim=999) # K-vecinos
```

Dado que el p-value para cada método o criterio es igual a 0.001, y este valor es menor a 0.05, significa que se muestran agrupaciones estadísticamente significativas.

## Prueba C de Geary:

El índice de Geary (`C`) es un índice de comparaciones por pares entre las diferentes zonas; por lo general varía entre 0 y 2. - Un valor de $1$ indica ausencia de autocorrelación, es decir, que los valores de una zona no están relacionados con los valores de zonas cercanas. - Los valores inferiores a $<1$ indican autocorrelación espacial positiva, - Mientras que valores superiores a $>1$ indican autocorrelación espacial negativa (Griffith, 1987).

`geary.test`: (Prueba `C` de Geary para autocorrelación espacial) Utiliza una matriz de ponderaciones espaciales en forma de lista de ponderaciones. La opción alternativa especifica la hipótesis alternativa, debe ser mayor (predeterminado), menor o como en este caso, bilateral (two.side).

```{r}
# Primero usamos tipo reina:
C_Geary_reina = geary.test(layer_municipios$IM_2020, listw = X_nbq_w, 
                             alternative = "two.side")

# Luego tipo torre
C_Geary_torre = geary.test(layer_municipios$IM_2020, listw = X_nbr_w, 
                             alternative = "two.side")

# Ahora, usamos k = 4:
C_Geary_k = geary.test(layer_municipios$IM_2020, listw = X_kn4_w, 
                         alternative = "two.side") 
```

Resultados

```{r}
C_Geary_reina
```

```{r}
C_Geary_torre
```

```{r}
C_Geary_k
```

Observamos el C de Geary para:

-   Criterio reina: C =0.3795
-   Criterio torre: C = 0.3772
-   k-vecinos: C = 0.4074

Conclusión Por lo que los valores son menores que 1, confirma la existencia de autocorrelación espacial positiva.

## Prueba del estadístico C de geary

`geary.mc`: Esta es una prueba de permutación para el estadístico C de Geary calculado usando permutaciones aleatorias.

```{r}
geary.mc(layer_municipios$IM_2020, listw = X_nbq_w, nsim = 999) # Reina
```

```{r}
geary.mc(layer_municipios$IM_2020, listw = X_nbr_w, nsim = 999) # Torre
```

```{r}
geary.mc(layer_municipios$IM_2020, listw = X_kn4_w, nsim = 999) # K-vecinos
```

Dado que el p-value para cada método o criterio es igual a 0.001, y este valor es menor a 0.05, significa que se muestran agrupaciones estadísticamente significativas.

## Prueba G(d) de Getis y Ord

globalG.test: La estadística G global para la autocorrelación espacial, que complementa las medidas locales de Gi LISA: localG..

```{r}
# Ahora, usando k = 4:
G_Getis_k = globalG.test(layer_municipios$IM_2020, listw = X_kn4_w, 
                         alternative = "two.side") 
G_Getis_k
```

## Representación gráfica de la dependencia espacial

n gráfico de dispersión que permite analizar la autocorrelación espacial global, es el denominado **Scatterplot de Moran univariante (Anselin, 1993)** .\
Este gráfico se construye en un plano cartesiano, en el eje de abscisas se ubican los valores de la variable de estudio estandarizada (x), y en el eje de ordenadas, se ubican los valores del retardo espacial de la variable estandarizada. Entiéndase por retardo espacial de una unidad espacial $i$, al valor medio de todos los valores de la variable estandarizada correspondientes a las unidades espaciales vecinas de $i$.

Si la nube de puntos tiende a formarse sobre la diagonal principal del plano cartesiano (cuadrante I y III, en contra de las manecillas de reloj), esto nos indicará la presencia de autocorrelación espacial positiva.

Si la nube de puntos tiende a ubicarse sobre la diagonal secundaria del plano cartesiano (cuadrante II y IV, en contra de las manecillas de reloj) , será un indicio de existencia de autocorrelación espacial negativa.

De lo contrario, si la nube de puntos de distribuye sobre los cuatro cuadrantes, esto nos indicará ausencia de autocorrelación espacial.

`moran.plot`: (Diagrama de dispersión de Moran) Una gráfica de datos espaciales frente a sus valores espaciales rezagados, aumentada al informar el resumen de las medidas de influencia para la relación lineal entre los datos y el rezago.

```{r}
scatterplot_moran = moran.plot(layer_municipios$IM_2020, listw = X_kn4_w, main = "Scatterplot de Moran para la pobreza", labels = unique(IMM_2020$CVE_MUN))
```

Dado que la nube de puntos tiende a formarse sobre la diagonal principal del plano cartesiano (cuadrante I y III), esto indica la presencia de autocorrelación espacial positiva.

## Prueba de presencia de autocorrelación espacial (local):

Anselin (1995) se refirió a esto como una estadística “LISA”, para Indicador local de autocorrelación espacial.

`localmoran`: La estadística local espacial I de Moran se calcula para cada zona en función del objeto de ponderaciones espaciales.

`lag.listw`: Usando una representación dispersa de listw de una matriz de ponderaciones espaciales, calcula el vector de retardo.

```{r}
criterio <- X_nbq_w
LISA <- function(criterio) {
  
          P = localmoran(layer_municipios$IM_2020, listw = criterio)
          cX = layer_municipios$IM_2020 - mean(layer_municipios$IM_2020) # IM - Media(IM)
          lagDV = lag.listw(X_nbq_w, layer_municipios$IM_2020) # Calcula el retardo (promedios)
          clagDV = lagDV - mean(lagDV) # Retardo - Media(Retardo)
          p = P[,5] # Toma la columna: Pr(z > 0) de P
        
          # Se inicializa vector numerico de longitud filas de P (666)
          quadrant = vector(mode="numeric",length=nrow(P))+5
          quadrant[cX>0 & clagDV>0 & p<= 0.05] = 1 # Alto-Alto
          quadrant[cX<0 & clagDV<0 & p<= 0.05] = 2 # Bajo-Bajo
          quadrant[cX<0 & clagDV>0 & p<= 0.05] = 3 # Bajo-Alto
          quadrant[cX>0 & clagDV<0 & p<= 0.05] = 4 # Alto-Bajo
        
          # Grafico  
          brks = c(1,2,3,4,5)
          colors = c("red", "blue", "light blue", "pink", "white")
          plot(layer_municipios, border ="lightgray", col=colors[findInterval(quadrant,brks,all.inside=FALSE)])
          legend("bottomright", legend = c("High-High", "Low-Low", "Low-High", "High-Low", "Insignificant"), fill = colors, bty="n", cex=0.7, y.intersp=1, x.intersp=1)
          box()
          title("LISA Cluster Map")
}
```

```{r}
LISA(criterio = X_nbq_w)
```

```{r, eval = FALSE}
tabla <- read.delim("C:/Users/dvill/Downloads/2022_12_3_00/2022_12_3_00.txt", sep = "\t", fill = TRUE , header = TRUE, quote = "\"")

require(Rcmdr)


#library(data.table)
#setDT(df)[, observacion_izquierda := shift(observacion, n = 1, fill = NA, type = "lead")]
```

## Librerías

**Librerías que se usaron en el trabajo**

```{r, echo = FALSE}
names(sessionInfo()$otherPkgs)
```

## Referencias

Anselin, L. (1995). Local Indicators of Spatial Association—LISA. Geographical Analysis, 27(2), 93–115.

Datos Abiertos de México - Índice de marginación (carencias poblacionales) por localidad, municipio y entidad. (2021). Retrieved February 13, 2022, from <https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad>

Bivand, R. S., Pebesma, E., & Gómez-Rubio, V. (2013). Applied Spatial Data Analysis with R (2nd ed.). Springer.

RPubs - Spatial Clustering of Univariate Geographically Referenced Attribute. (2020). Retrieved January 30, 2025, from <https://rpubs.com/erikaaldisa/spatialclustering>
